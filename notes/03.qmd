---
title: "Value, Ref, Types"
subtitle: "VS and sln"
documenttype: Handout
abstract: |
  ""
categories:
version: [v.1.0]
date: last-modified
---

## `C#`의 형식(types)

C#은 강력한 형식 시스템을 가진 언어로, 데이터의 종류를 명확하게 구분하여 안정적인 프로그래밍을 지원합니다. C#의 모든 형식은 값 형식(Value Types) 또는 참조 형식(Reference Types) 중 하나에 속합니다.

### 값 형식(value types)

값 형식은 데이터를 직접 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 복사본이 생성되어 저장됩니다.

```csharp
int a = 10;
int b = a; // b에 a 값이 '복사'되어 들어감, a가 10에서 다른 값으로 바뀌더라도 b에는 영향 없음
```

- 스택과 값 형식: 값 형식의 데이터는 메모리의 스택(Stack) 영역에 저장, 스택은 비교적 빠르고 크기가 제한된 메모리 영역, 함수 호출과 반환에 따라 메모리가 자동으로 관리

- 숫자 데이터 형식:
  - 정수 계열: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`
  - 실수 계열: `float`, `double`, `decimal`
- 문자 형식: `char` (유니코드 문자 하나)
- 논리 형식: `bool` (true 또는 false)
- 열거 형식 (enum): 명명된 상수 집합을 정의하는 형식.
- 구조체 (struct): 사용자 정의 값 형식. 여러 개의 값 형식을 묶어서 하나의 복합적인 데이터 형식을 만들 수 있습니다.

### 참조 형식(reference types)

참조 형식은 데이터가 저장된 메모리 주소를 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 주소가 복사되어 저장됩니다. 따라서 여러 변수가 동일한 데이터를 참조할 수 있습니다.

```csharp
string s1 = "Hello";
string s2 = s1; 
// s2에는 s1과 동일한 "Hello"라는 문자열 객체의 참조가 복사됨, s1이나 s2 중 하나를 변경하면,(string은 불변(Immutable) 특성을 갖지만)
// 새로운 문자열 객체가 생성되는 등의 과정에서 참조가 달라질 수 있음
```

- 힙과 참조 형식: 참조 형식의 데이터는 메모리의 힙(Heap) 영역에 저장, 힙은 스택보다 크기가 크지만, 메모리 관리를 프로그래머가 어느 정도 신경 써야함(가비지 컬렉터가 자동적으로 관리)
- 문자열 형식: `string` (유니코드 문자열)
- object 형식: 모든 형식의 조상 형식. 모든 값 형식과 참조 형식은 `object` 형식으로 암시적 변환이 가능
- 클래스 (class): 사용자 정의 참조 형식. 객체 지향 프로그래밍의 핵심 요소
- 인터페이스 (interface): 메서드 시그니처의 집합을 정의하는 형식
- 배열 (array): 동일한 형식의 데이터들을 연속적으로 저장하는 형식
- 델리게이트 (delegate): 메서드를 참조하는 형식

### 기초 예제

- 디버거에서 변수 관찰
  - Visual Studio 또는 VS Code 디버깅 기능 사용
  - 브레이크포인트를 걸고, 지역 변수와 힙에 있는 객체(참조 형식)를 "Autos"나 "Locals" 창에서 확인
  - 스택 프레임을 확인하며, 값 형식이 어떻게 스택에 놓이는지, 참조 형식은 어디에 놓이는지를 눈으로 보면서 익힘
  - 코드를 디버그 모드로 실행하여 s1, s2, c1, c2 변수가 가리키는 대상을 확인
    - s2는 새로운 값(20)을 가지지만, s1은 여전히 10을 유지하고 있음을 확인할 수 있음(값 복사)
    - c2 값을 변경하면, c1도 바뀌는 것을 볼 수 있음(동일 객체 참조)

- IL(중간 언어) 코드 확인
  - `C#` 코드는 `.NET`의 중간 언어(`IL`, `Intermediate Language`)로 컴파일됨
  - `IL` 디컴파일러(예: `ILSpy`, `dotPeek`)를 사용해 대입 시 박싱/언박싱이 일어나는지, 값 복사가 어떻게 구현되는지 등을 확인할 수 있음
  - `IL` 코드를 보면 `stloc`, `ldloc` 등 명령어로 스택에 변수가 어떻게 로드/저장되는지 이해가 가능해짐

- 메모리 분석 도구 사용
  - `dotMemory`, Visual Studio 진단 도구(Diagnostic Tools) 등 메모리 분석 도구를 활용
  - 프로그램 실행 중 힙에 어떤 객체가 얼마만큼 올라가 있고, GC가 언제 일어나는지 추적할 수 있음
  - 값 형식은 힙에 직접 올라가지 않지만(참조 형식의 필드로 쓰인 경우는 내부적으로 참조로 연결됨), 참조 형식이 힙에서 어떻게 배치되는지 실제 현황을 확인 가능

```csharp
using System;

public struct MyStruct
{
    public int Value;
}

public class MyClass
{
    public int Value;
}

class Program
{
    static void Main()
    {
        // 1. 구조체 (값 형식)
        MyStruct s1 = new MyStruct { Value = 10 };
        MyStruct s2 = s1;   // 값 복사
        s2.Value = 20;

        Console.WriteLine($"s1.Value = {s1.Value}"); // 10
        Console.WriteLine($"s2.Value = {s2.Value}"); // 20

        // 2. 클래스 (참조 형식)
        MyClass c1 = new MyClass { Value = 10 };
        MyClass c2 = c1;    // 참조 복사
        c2.Value = 20;

        Console.WriteLine($"c1.Value = {c1.Value}"); // 20
        Console.WriteLine($"c2.Value = {c2.Value}"); // 20
    }
}
```

### 심화 예제

"값 형식 안에도 참조가 들어갈 수 있다"는 점을 직접 실험해 보면, 단순히 "값 형식=스택, 참조 형식=힙"이라고 끝나는 게 아니라는 것을 확인 할 수 있습니다.

- PersonStruct는 분명히 값 형식이지만, 내부에 string(참조 형식)을 가지고 있으므로
  - 문자열 자체는 힙에 저장
  - 구조체 안의 Name 필드는 문자열 객체의 주소를 값으로 갖고 있는 형태

- `Span<T>`, `ref struct` 등
  - 최신 C# 문법에서는 스택만을 대상으로 하는 구조(`ref struct`)가 등장(`Span<T>`, `ReadOnlySpan<T>` 등)
  - 이런 타입들은 스택에만 존재해야 하며, 힙에 들어갈 수 없도록 CLR/C# 컴파일러가 제약을 걸어놓음

- 인라인(Inline) 할당, Escape Analysis
  - C#/.NET이 내부적으로 Escape Analysis(값이 스택 범위를 벗어나는지 분석)를 해서 구조체를 최적화하거나, 때로는 힙 대신 스택에 할당할 수도 있음(C# 7 이상, 일부 시나리오)
  - 이런 최적화는 코드 레벨에서 바로 체감하기 어렵지만, 런타임의 최적화 원리를 이해해두면 좋음

```
public struct PersonStruct
{
    public string Name; // 참조 형식 필드
    public int Age;
}

```

## 박싱과 언박싱(boxing and unboxing)

- 박싱: 값 형식을 참조 형식인 `object` 형식으로 변환하는 과정, 힙에 새로운 객체를 할당하고 값 형식의 데이터를 복사
```csharp
int num = 123;
object boxed = num; // int -> object로 박싱
```

- 언박싱: `object` 형식에서 값 형식으로 다시 변환하는 과정, 힙에 저장된 데이터를 스택으로 복사
```csharp
object boxedNum = 123;
int unboxedNum = (int)boxedNum; // 언박싱: int 형식으로 명시적 캐스팅
```

## 문자열 다루기(string manipulation)

- 찾기: 문자열 내에서 특정 문자 또는 문자열의 위치를 찾는 메서드(`IndexOf`, `LastIndexOf`, `Contains` 등)
```csharp
string greeting = "Hello World";
int indexOfW = greeting.IndexOf('W'); // 6
bool hasHello = greeting.Contains("Hello"); // true
```

- 변형: 문자열의 내용을 변경하는 메서드(`ToUpper`, `ToLower`, `Trim`, `Replace` 등)
```csharp
string sample = "  Hello World  ";
string upper = sample.ToUpper(); // "  HELLO WORLD  "
string trimmed = sample.Trim();  // "Hello World"
string replaced = sample.Replace("World", "C#"); // "  Hello C#  "
```

- 분할: 문자열을 특정 구분자를 기준으로 여러 부분으로 나누는 메서드(`Split`)
```csharp
string fruitList = "Apple,Banana,Cherry";
string[] fruits = fruitList.Split(',');
// fruits[0] = "Apple"
// fruits[1] = "Banana"
// fruits[2] = "Cherry"
```

- 서식: 문자열의 형식을 지정하는 방법(`string.Format`, 보간된 문자열 `$""`)
```csharp
int age = 25;
string name = "홍길동";
// 1) string.Format 사용
string result1 = string.Format("이름: {0}, 나이: {1}", name, age);
// 2) 보간 문자열 사용($"" 또는 @$"")
string result2 = $"이름: {name}, 나이: {age}";
```

## 데이터를 가공하는 연산자(operators)

- 산술 연산자: `+`, `-`, `*`, `/`, `%`
```csharp
int x = 10;
int y = 3;
Console.WriteLine(x + y); // 13
Console.WriteLine(x - y); // 7
Console.WriteLine(x * y); // 30
Console.WriteLine(x / y); // 3  (정수 나눗셈)
Console.WriteLine(x % y); // 1
```

- 증가 연산자와 감소 연산자: `++`, `--` (전위, 후위)
```csharp
int num = 5;
Console.WriteLine(num++); // 5 (출력 후에 증가)
Console.WriteLine(num);   // 6
Console.WriteLine(++num); // 7 (미리 증가 후에 출력)
```

- 문자열 결합 연산자: `+`
```csharp
string hello = "Hello";
string world = "World";
string combined = hello + " " + world; // "Hello World"
```

- 관계 연산자: `==`, `!=`, `>`, `<`, `>=`, `<=`
```csharp
int a = 10, b = 20;
Console.WriteLine(a == b); // false
Console.WriteLine(a != b); // true
Console.WriteLine(a > b);  // false
```

- 논리 연산자: `&&`, `||`, `!`
```csharp
bool c = true, d = false;
Console.WriteLine(c && d); // false
Console.WriteLine(c || d); // true
Console.WriteLine(!c);     // false
```

- 조건 연산자 (삼항 연산자): `?:`
```csharp
int score = 85;
string result = (score >= 60) ? "합격" : "불합격";
```

- 비트 연산자: `&`, `|`, `^`, `~`, `<<`, `>>`
```csharp
int e = 10;    // 1010 (2진수)
int f = 12;    // 1100 (2진수)
Console.WriteLine(e & f); // 8 (1000)
Console.WriteLine(e | f); // 14(1110)
Console.WriteLine(e ^ f); // 6 (0110)

int g = 1;
Console.WriteLine(g << 2); // 4  (1을 왼쪽으로 2비트 이동)
Console.WriteLine(g >> 1); // 0  (1을 오른쪽으로 1비트 이동)
```

- 할당 연산자: `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
```csharp
int h = 10;
h += 5;  // h = 15
h <<= 1; // h = 30 (이진수로 한 칸 왼쪽 이동)
```

- null 조건부 연산자: `?.` (null인 경우 null 반환), 
- null 병합 연산자: `??` (null인 경우 다른 값 반환)
```csharp
string? nullString = null;
int? length = nullString?.Length; // nullString이 null이면 전체 결과가 null
string? maybeNull = null;
string resultString = maybeNull ?? "값이 null이었어요"; 
// maybeNull이 null이면 뒤의 "값이 null이었어요" 대입
```

## 기타 형식 관련 내용

- 데이터 형식 바꾸기(type conversion):
  - 암시적 변환 (Implicit Conversion): 데이터 손실이 없는 경우 자동으로 수행되는 변환
  - 명시적 변환 (Explicit Conversion/Casting): 데이터 손실이 발생할 수 있는 경우 명시적으로 지정해야 하는 변환

```csharp
long bigNum = 123456789;
int smallerNum = (int)bigNum; // 명시적 캐스팅
```

- 상수(const): 컴파일 시간에 값이 결정되는 변하지 않는 값
```csharp
const double PI = 3.141592;
```

- nullable 형식(nullable types): 값 형식이 `null` 값을 가질 수 있도록 하는 형식. `int?`, `bool?` 등의 형태로 사용
```csharp
int? x = null;
x = 10;
```

- var 형식(var keyword): 컴파일러가 변수의 형식을 추론하도록 하는 키워드. 지역 변수 선언 시에만 사용 가능
```csharp
var number = 10;      // number는 int로 추론
var text = "Hello";   // text는 string으로 추론
```

- 공용 형식 시스템(common type system, cts): .net 런타임 환경에서 모든 형식이 어떻게 표현되고 사용되는지를 정의하는 명세(int → System.Int32, string → System.String 등)

### 예제

```csharp
using System;

public class Program
{
    public static void Main()
    {
        // 값 형식 예시
        int valueA = 10;
        int valueB = valueA;
        valueB = 20;
        Console.WriteLine($"valueA = {valueA}, valueB = {valueB}"); 
        // valueA = 10, valueB = 20 (복사본이기 때문)

        // 참조 형식 예시
        Person person1 = new Person();
        person1.Name = "Kim";

        Person person2 = person1; // 같은 참조를 복사
        person2.Name = "Lee";

        Console.WriteLine($"person1.Name = {person1.Name}, person2.Name = {person2.Name}");
        // person1.Name = Lee, person2.Name = Lee (같은 객체 참조)
    }
}

public class Person
{
    public string Name;
}
```

값 형식과 참조 형식의 메모리 구조 더 깊이 이해

구조체(struct)를 직접 만들어보거나, 클래스와의 차이점을 확인해보면 좋아요.
박싱/언박싱 오버헤드 체험

대량의 박싱이 발생하는 코드를 만들어보고(예: ArrayList vs. List<T>) 성능 차이를 비교해보세요.
문자열 다루기 연습

문자열 보간, StringBuilder, 정규 표현식(Regex) 등을 활용해보면 더 풍부한 경험을 쌓을 수 있습니다.
연산자 우선순위와 다양한 연산자 활용

복잡한 식(수식)에서 연산자 우선순위를 어떻게 처리하는지 살펴보는 것도 유용합니다.