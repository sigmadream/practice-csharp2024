<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-01-30">

<title>Visual Studio와 Solution – Practice C#</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-fad5ab29a14bbe0a7a7d29177f3f13bb.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Visual Studio와 Solution – Practice C#">
<meta property="og:description" content="“Visual Studio는 1997년 출시 이후 통합 개발 환경(IDE)으로서 다양한 프로그래밍 언어와 플랫폼을 지원하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 주요 구성 요소로는 메뉴 바, 도구 모음, 솔루션 탐색기, 코드 편집기, 도구 창, 솔루션 및 프로젝트 탭, 상태 표시줄 등이 있으며, 주요 기능으로는 통합된 개발 환경, 효율적인 솔루션 및 프로젝트 관리, 강력한 디버깅 및 진단 기능, Git 등 버전 관리 시스템과의 통합, 확장 가능한 마켓플레이스, IntelliSense, 코드 리팩터링, 테스팅 및 품질 보증, 팀 협업 등이 있습니다. 다양한 프로젝트 유형(콘솔 앱, 클래스 라이브러리, 단위 테스트, 웹 앱, .NET MAUI 앱 등)을 지원하며, 프로젝트는 코드, 리소스, 구성을 포함하는 핵심 개체입니다. 프로젝트는 솔루션이라는 컨테이너에 담기며, 솔루션 파일(.sln), 프로젝트 파일(.csproj 등), 소스 코드 파일, 리소스 파일, 구성 파일 등으로 구성됩니다. 디버깅은 F5, Ctrl+F5, 메뉴 또는 도구 모음 버튼을 통해 시작할 수 있으며, 중단점, 단계별 실행, 조사식, 로컬, 직접 실행 창, 호출 스택 등의 기능을 제공하고, 진단 도구, 성능 프로파일링, IntelliTrace, 코드 분석 등의 도구를 활용할 수 있습니다. 이러한 기능들을 통해 개발자는 효율적으로 고품질의 소프트웨어를 개발하고 유지보수할 수 있습니다.”">
<meta property="og:site_name" content="Practice C#">
<meta name="twitter:title" content="Visual Studio와 Solution – Practice C#">
<meta name="twitter:description" content="“Visual Studio는 1997년 출시 이후 통합 개발 환경(IDE)으로서 다양한 프로그래밍 언어와 플랫폼을 지원하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 주요 구성 요소로는 메뉴 바, 도구 모음, 솔루션 탐색기, 코드 편집기, 도구 창, 솔루션 및 프로젝트 탭, 상태 표시줄 등이 있으며, 주요 기능으로는 통합된 개발 환경, 효율적인 솔루션 및 프로젝트 관리, 강력한 디버깅 및 진단 기능, Git 등 버전 관리 시스템과의 통합, 확장 가능한 마켓플레이스, IntelliSense, 코드 리팩터링, 테스팅 및 품질 보증, 팀 협업 등이 있습니다. 다양한 프로젝트 유형(콘솔 앱, 클래스 라이브러리, 단위 테스트, 웹 앱, .NET MAUI 앱 등)을 지원하며, 프로젝트는 코드, 리소스, 구성을 포함하는 핵심 개체입니다. 프로젝트는 솔루션이라는 컨테이너에 담기며, 솔루션 파일(.sln), 프로젝트 파일(.csproj 등), 소스 코드 파일, 리소스 파일, 구성 파일 등으로 구성됩니다. 디버깅은 F5, Ctrl+F5, 메뉴 또는 도구 모음 버튼을 통해 시작할 수 있으며, 중단점, 단계별 실행, 조사식, 로컬, 직접 실행 창, 호출 스택 등의 기능을 제공하고, 진단 도구, 성능 프로파일링, IntelliTrace, 코드 분석 등의 도구를 활용할 수 있습니다. 이러한 기능들을 통해 개발자는 효율적으로 고품질의 소프트웨어를 개발하고 유지보수할 수 있습니다.”">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Practice C#</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Visual Studio와 Solution</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notes/01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">C#과 .NET</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#visual-sutdio" id="toc-visual-sutdio" class="nav-link active" data-scroll-target="#visual-sutdio">Visual Sutdio</a>
  <ul class="collapse">
  <li><a href="#visual-studio-구성-요소" id="toc-visual-studio-구성-요소" class="nav-link" data-scroll-target="#visual-studio-구성-요소">Visual Studio 구성 요소</a></li>
  <li><a href="#visual-studio-주요-기능-및-도구-개요" id="toc-visual-studio-주요-기능-및-도구-개요" class="nav-link" data-scroll-target="#visual-studio-주요-기능-및-도구-개요">Visual Studio 주요 기능 및 도구 개요</a></li>
  </ul></li>
  <li><a href="#프로젝트-유형" id="toc-프로젝트-유형" class="nav-link" data-scroll-target="#프로젝트-유형">프로젝트 유형</a></li>
  <li><a href="#프로젝트-생성과-솔루션" id="toc-프로젝트-생성과-솔루션" class="nav-link" data-scroll-target="#프로젝트-생성과-솔루션">프로젝트 생성과 솔루션</a>
  <ul class="collapse">
  <li><a href="#솔루션-파일" id="toc-솔루션-파일" class="nav-link" data-scroll-target="#솔루션-파일">솔루션 파일</a></li>
  <li><a href="#솔루션을-구성하는-파일" id="toc-솔루션을-구성하는-파일" class="nav-link" data-scroll-target="#솔루션을-구성하는-파일">솔루션을 구성하는 파일</a></li>
  </ul></li>
  <li><a href="#디버깅" id="toc-디버깅" class="nav-link" data-scroll-target="#디버깅">디버깅</a>
  <ul class="collapse">
  <li><a href="#디버깅-기능" id="toc-디버깅-기능" class="nav-link" data-scroll-target="#디버깅-기능">디버깅 기능</a></li>
  <li><a href="#디버깅-도구" id="toc-디버깅-도구" class="nav-link" data-scroll-target="#디버깅-도구">디버깅 도구</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Visual Studio와 Solution</h1>
<p class="subtitle lead">VS and sln</p>
  <div class="quarto-categories">
    <div class="quarto-category">VS</div>
    <div class="quarto-category">VS2020</div>
    <div class="quarto-category">Solution</div>
    <div class="quarto-category">sln</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    <p>“Visual Studio는 1997년 출시 이후 통합 개발 환경(IDE)으로서 다양한 프로그래밍 언어와 플랫폼을 지원하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 주요 구성 요소로는 메뉴 바, 도구 모음, 솔루션 탐색기, 코드 편집기, 도구 창, 솔루션 및 프로젝트 탭, 상태 표시줄 등이 있으며, 주요 기능으로는 통합된 개발 환경, 효율적인 솔루션 및 프로젝트 관리, 강력한 디버깅 및 진단 기능, Git 등 버전 관리 시스템과의 통합, 확장 가능한 마켓플레이스, IntelliSense, 코드 리팩터링, 테스팅 및 품질 보증, 팀 협업 등이 있습니다. 다양한 프로젝트 유형(콘솔 앱, 클래스 라이브러리, 단위 테스트, 웹 앱, .NET MAUI 앱 등)을 지원하며, 프로젝트는 코드, 리소스, 구성을 포함하는 핵심 개체입니다. 프로젝트는 솔루션이라는 컨테이너에 담기며, 솔루션 파일(.sln), 프로젝트 파일(.csproj 등), 소스 코드 파일, 리소스 파일, 구성 파일 등으로 구성됩니다. 디버깅은 F5, Ctrl+F5, 메뉴 또는 도구 모음 버튼을 통해 시작할 수 있으며, 중단점, 단계별 실행, 조사식, 로컬, 직접 실행 창, 호출 스택 등의 기능을 제공하고, 진단 도구, 성능 프로파일링, IntelliTrace, 코드 분석 등의 도구를 활용할 수 있습니다. 이러한 기능들을 통해 개발자는 효율적으로 고품질의 소프트웨어를 개발하고 유지보수할 수 있습니다.”</p>
  </div>
</div>


</header>


<section id="visual-sutdio" class="level2">
<h2 class="anchored" data-anchor-id="visual-sutdio">Visual Sutdio</h2>
<p>Visual Studio는 1997년 Microsoft에서 처음 출시되었습니다. 당시에는 여러 개발 도구를 하나의 통합된 환경으로 제공하는 것을 목표로 하였습니다. 이전에는 Visual Basic, Visual C++, Visual FoxPro 등 개별적인 도구들을 사용해야 했지만, Visual Studio의 등장으로 이러한 도구들이 하나의 IDE(Integrated Development Environment, 통합 개발 환경) 안에서 통합되었습니다. 이를 통해 개발자들은 더욱 효율적으로 다양한 프로그래밍 언어를 사용하여 애플리케이션을 개발할 수 있게 되었습니다. 초기 버전의 Visual Studio는 주로 Windows 데스크톱 애플리케이션 개발에 초점을 맞추었습니다.</p>
<p>2000년대에 들어서면서 웹 애플리케이션의 중요성이 커짐에 따라 Visual Studio는 ASP.NET과 같은 웹 개발 기술을 적극적으로 지원하기 시작했습니다. 또한, 엔터프라이즈급 애플리케이션 개발을 위한 기능들이 추가되면서 대규모 프로젝트 개발에도 적합한 도구로 자리매김하게 되었습니다. .NET Framework의 발전과 함께 Visual Studio는 더욱 강력한 기능을 제공하게 되었으며, 다양한 프로그래밍 언어(C#, VB.NET 등)를 지원하며 개발 생산성을 향상시키는 데 기여했습니다.</p>
<p>2010년대 이후 모바일 및 클라우드 컴퓨팅이 급성장하면서 Visual Studio는 크로스 플랫폼 개발 및 클라우드 개발을 위한 지원을 강화했습니다. Xamarin을 통한 iOS, Android, Windows 등 다양한 플랫폼 대상의 모바일 앱 개발을 지원하고, Azure와의 통합을 통해 클라우드 기반 애플리케이션 개발을 용이하게 만들었습니다. 또한, 오픈 소스 생태계와의 협력을 강화하여 Git과 같은 버전 관리 시스템과의 통합을 개선하고 다양한 확장 기능을 제공하는 Visual Studio Marketplace를 통해 개발자들이 더욱 편리하게 개발할 수 있도록 지원하고 있습니다.</p>
<p>Visual Studio는 출시 이후 지속적인 발전을 거듭하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 다양한 프로그래밍 언어와 플랫폼을 지원하는 통합 개발 환경으로서 개발자들이 효율적으로 고품질의 소프트웨어를 개발할 수 있도록 지원하는 핵심적인 역할을 수행하고 있습니다. 또한, 강력한 디버깅 도구, 코드 분석 기능, 테스트 도구 등을 통해 개발 과정 전반의 생산성을 향상시키는 데 기여하고 있습니다. 현재 Visual Studio는 Windows뿐만 아니라 macOS에서도 사용할 수 있는 Visual Studio for Mac, 그리고 더욱 가볍고 빠른 코드 편집기인 Visual Studio Code 등 다양한 형태로 제공되어 개발자들이 자신의 환경에 맞춰 선택하여 사용할 수 있도록 폭넓은 선택지를 제공하고 있습니다.</p>
<section id="visual-studio-구성-요소" class="level3">
<h3 class="anchored" data-anchor-id="visual-studio-구성-요소">Visual Studio 구성 요소</h3>
<p>Visual Studio를 처음 실행하면 사용자 설정에 맞게 다양하게 사용자 조정할 수 있는 작업 공간을 확인할 수 있습니다. 인터페이스의 주요 구성 요소는 다음과 같습니다.</p>
<ul>
<li><p>메뉴 바(menu bar): 상단에 위치한 메뉴 바는 파일, 편집, 보기 등과 같은 메뉴로 구성된 다양한 명령과 옵션에 대한 액세스를 제공합니다.</p></li>
<li><p>도구 모음(toolbar): 메뉴 바 아래에는 자주 사용하는 도구와 작업에 대한 빠른 액세스를 제공하는 도구 모음이 있습니다. 프로젝트 빌드, 디버깅 및 실행과 같은 작업에 대한 버튼을 포함하는 경우가 많습니다.</p></li>
<li><p>솔루션 탐색기(solution explorer): 화면 오른쪽에는 솔루션 탐색기가 있으며, 프로젝트 및 해당 파일을 관리하는 데 중요한 도구입니다. 솔루션과 해당 구성 요소의 계층적 보기를 표시합니다.</p></li>
<li><p>코드 편집기(code editor): IDE의 중앙 영역은 코드 편집기가 차지합니다. 여기에서 소스 코드 파일을 작성, 편집 및 검토합니다. Visual Studio는 구문 강조, 코드 완성 및 오류 검사를 포함한 강력한 코드 편집 기능을 제공합니다.</p></li>
<li><p>도구 창(tool windows): 이러한 창은 IDE 인터페이스에 도킹 또는 해제할 수 있는 추가 창입니다. 예를 들어 빌드 및 디버그 메시지를 표시하는 출력 창, 선택한 항목의 속성을 구성하는 속성 창, 코드 오류를 관리하는 오류 목록 창 등이 있습니다.</p></li>
<li><p>솔루션 및 프로젝트 탭(solution and project tabs): 코드 편집기 위의 탭은 열려 있는 솔루션과 프로젝트를 나타냅니다. 해당 탭을 클릭하여 다른 솔루션 또는 프로젝트 간에 전환할 수 있습니다.</p></li>
<li><p>상태 표시줄(Status Bar): IDE의 맨 아래에 있는 상태 표시줄은 현재 줄 및 열 번호와 같은 필수 정보를 제공하며, 줄 끝 및 코드 페이지와 같은 기능을 전환하기 위한 다양한 버튼도 포함합니다.</p></li>
</ul>
</section>
<section id="visual-studio-주요-기능-및-도구-개요" class="level3">
<h3 class="anchored" data-anchor-id="visual-studio-주요-기능-및-도구-개요">Visual Studio 주요 기능 및 도구 개요</h3>
<p>Visual Studio는 풍부한 기능과 도구 세트를 제공합니다.</p>
<ul>
<li><p>Integrated Development Environment (IDE), Visual Studio는 핵심적으로 종합적인 통합 개발 환경(IDE)입니다. 구문 강조, 코드 완성, 오류 검사와 같은 기능을 갖춘 강력한 코드 편집기를 제공합니다. 코드 편집기는 다양한 프로그래밍 언어를 지원하여 다양한 개발 작업에 유연하게 활용할 수 있습니다.</p></li>
<li><p>솔루션 및 프로젝트 관리, Visual Studio는 코드와 리소스를 효율적으로 구성하는 데 도움이 되는 솔루션 및 프로젝트 개념을 도입합니다. 솔루션은 여러 프로젝트를 포함할 수 있으므로 복잡한 애플리케이션을 쉽게 관리할 수 있습니다. 솔루션 탐색기는 솔루션의 계층적 보기를 제공하고 프로젝트 파일을 쉽게 탐색 및 조작할 수 있게 합니다.</p></li>
<li><p>디버깅 및 진단, 디버깅은 소프트웨어 개발의 중요한 부분이며 Visual Studio는 이 분야에서 탁월합니다. 중단점, 감시 창, 호출 스택과 같은 기능을 갖춘 강력한 디버거를 제공합니다. Visual Studio의 진단 도구를 사용하면 응용 프로그램 성능, 메모리 사용량 및 코드 프로파일링을 분석하여 문제를 효과적으로 식별하고 해결할 수 있습니다.</p></li>
<li><p>버전 관리 통합, Visual Studio는 Git, Team Foundation Version Control (TFVC) 등과 같은 인기있는 버전 관리 시스템과 완벽하게 통합됩니다. 이 통합은 협업 개발, 효율적인 코드 공유 및 변경 사항 추적을 용이하게 합니다. IDE 내에서 직접 커밋, 분기, 병합 및 충돌 해결을 수행할 수 있습니다.</p></li>
<li><p>확장성 및 마켓플레이스, Visual Studio의 확장성은 뛰어난 기능입니다. Visual Studio Marketplace에서 확장 프로그램과 애드온을 설치하여 IDE의 기능을 향상시킬 수 있습니다. 이러한 확장 프로그램은 생산성 도구에서 코드 분석 및 프로젝트 템플릿에 이르기까지 다양합니다. 마켓플레이스는 Microsoft와 커뮤니티가 만든 확장 프로그램 모두를 위한 허브입니다.</p></li>
<li><p>IntelliSense, IntelliSense는 코드 완성 및 제안 기능으로 생산성을 크게 향상시킵니다. 입력할 때 상황에 맞는 제안을 제공하여 메서드 이름, 변수 이름 및 API 세부 사항을 기억해야 하는 필요성을 줄여줍니다. IntelliSense는 여러 프로그래밍 언어 및 프레임워크를 지원합니다.</p></li>
<li><p>코드 리팩터링, Visual Studio에는 코드 품질과 유지 관리 보수성을 향상시키는 데 도움이 되는 코드 리팩터링 도구 세트가 포함되어 있습니다. 변수 이름 바꾸기, 메서드 추출, 필드 캡슐화 등의 작업을 몇 번의 클릭만으로 쉽게 수행할 수 있습니다. 리팩터링 도구는 깨끗하고 효율적인 코드 작성을 지원합니다.</p></li>
<li><p>테스팅 및 품질 보증, Visual Studio는 단위 테스트 프레임워크, 통합 테스트 및 코드 커버리지 분석을 포함한 포괄적인 테스팅 도구를 제공합니다. 테스트 케이스를 생성하고 실행하며, 테스팅 프로세스를 자동화하고, 지속적인 통합 및 배포를 통해 소프트웨어의 품질을 보장할 수 있습니다.</p></li>
<li><p>협업 및 팀 개발, Visual Studio는 Team Foundation Server (TFS) 및 Git 통합과 같은 도구를 통해 팀 구성원 간의 협업을 지원합니다. 작업 항목을 관리하고, 진행 상황을 추적하며, 팀 개발을 위한 모범 사례를 구현할 수 있습니다. 공동 코딩 기능인 Live Share를 사용하면 팀원과 실시간 코드 공유 및 디버깅이 가능합니다.</p></li>
</ul>
</section>
</section>
<section id="프로젝트-유형" class="level2">
<h2 class="anchored" data-anchor-id="프로젝트-유형">프로젝트 유형</h2>
<p>소프트웨어 개발 분야에서 프로젝트는 코드, 리소스 및 구성을 포함하는 핵심 개체입니다. Visual Studio는 프로젝트를 효율적으로 만들고, 구성하고, 관리하기 위한 강력한 환경을 제공합니다. Visual Studio는 다양한 프로젝트 유형을 지원하며, 각 유형은 특정 개발 시나리오에 맞게 조정됩니다. 새 프로젝트를 만들 때 개발 목표에 해당하는 프로젝트 템플릿을 선택할 수 있습니다. 몇 가지 일반적인 프로젝트 유형은 다음과 같습니다.</p>
<ul>
<li>콘솔 응용 프로그램, 명령줄 인터페이스가 없는 명령 실행 응용 프로그램을 만드는 데 사용됩니다.</li>
<li>클래스 라이브러리, 여러 프로젝트에서 공유할 수 있는 재사용 가능한 클래스 라이브러리를 만드는 데 사용됩니다.</li>
<li>단위 테스트 프로젝트, 코드의 작은 단위 기능을 검증하도록 설계된 개별 테스트인 단위 테스트를 만드는 데 사용됩니다.</li>
<li>ASP.NET 웹 응용 프로그램, ASP.NET 프레임워크(Microsoft의 인기 웹 개발 프레임워크)를 사용하여 웹 응용 프로그램을 빌드하는 데 적합합니다.</li>
<li>.NET MAUI APP, 하나의 C# 코드베이스로 Android, iOS, macOS, Windows에서 실행되는 네이티브 모바일 및 데스크톱 애플리케이션을 구축하기 위한 크로스 플랫폼 프레임워크를 사용하여 만든 앱입니다.</li>
</ul>
</section>
<section id="프로젝트-생성과-솔루션" class="level2">
<h2 class="anchored" data-anchor-id="프로젝트-생성과-솔루션">프로젝트 생성과 솔루션</h2>
<ol type="1">
<li><code>파일(File)</code> 메뉴를 클릭합니다.</li>
<li><code>새로 만들기(New)</code>를 선택한 다음 <code>프로젝트(Project)</code>를 선택합니다.</li>
<li><code>새 프로젝트 만들기(Create a new project)</code> 대화 상자에서 요구 사항에 따라 원하는 프로젝트 템플릿을 검색하고 선택할 수 있습니다.</li>
<li><code>프로젝트 이름</code>, <code>위치</code> 및 <code>솔루션 이름</code>과 같은 프로젝트 설정을 구성합니다.</li>
<li><code>만들기(Create)</code> 버튼을 클릭하여 프로젝트 구조와 초기 파일을 생성합니다.</li>
</ol>
<section id="솔루션-파일" class="level3">
<h3 class="anchored" data-anchor-id="솔루션-파일">솔루션 파일</h3>
<p>Visual Studio의 솔루션은 하나 이상의 프로젝트를 담을 수 있는 컨테이너입니다. 솔루션은 관련 프로젝트를 함께 그룹화하고 프로젝트 간의 종속성을 관리하는 데 사용됩니다. 새 프로젝트를 만들면 일반적으로 Visual Studio는 해당 프로젝트를 보관할 솔루션을 만듭니다. 이러한 솔루션은 탐색기를 활용해서 확인할 수 있습니다.</p>
<p>솔루션 탐색기는 솔루션 내에서 프로젝트와 해당 파일을 관리하는 데 중요한 도구입니다. 보기 메뉴에서 또는 “Ctrl + Alt + L”을 눌러 액세스할 수 있습니다. 솔루션 탐색기에서는 다음을 수행할 수 있습니다:</p>
<ul>
<li>솔루션 및 프로젝트의 계층 구조를 볼 수 있습니다.</li>
<li>파일을 추가, 제거 및 정리합니다.</li>
<li>프로젝트 종속성을 설정합니다.</li>
<li>프로젝트 속성을 구성합니다.</li>
</ul>
</section>
<section id="솔루션을-구성하는-파일" class="level3">
<h3 class="anchored" data-anchor-id="솔루션을-구성하는-파일">솔루션을 구성하는 파일</h3>
<p>솔루션은 하나 이상의 프로젝트를 담는 컨테이너 역할을 하며, 프로젝트들은 실제 코드, 리소스, 설정 등을 포함합니다. 솔루션과 관련된 중요한 파일들을 이해하는 것은 Visual Studio를 효율적으로 사용하는 데 필수적입니다.</p>
<section id="솔루션-파일.sln" class="level4">
<h4 class="anchored" data-anchor-id="솔루션-파일.sln">솔루션 파일(.sln)</h4>
<ul>
<li>솔루션의 구성 정보를 담고 있음</li>
<li>어떤 프로젝트들이 솔루션에 포함되어 있는지, 프로젝트들의 상대적인 위치, 빌드 구성(Debug, Release 등) 정보 등을 포함</li>
<li>텍스트 기반 파일이며, 직접 편집할 수도 있지만 Visual Studio에서 관리하는 것이 권장</li>
</ul>
</section>
<section id="프로젝트-파일.csproj-.vbproj-.vcxproj-등" class="level4">
<h4 class="anchored" data-anchor-id="프로젝트-파일.csproj-.vbproj-.vcxproj-등">프로젝트 파일(.csproj, .vbproj, .vcxproj 등)</h4>
<ul>
<li>개별 프로젝트의 구성 정보를 담고 있음</li>
<li>프로젝트 유형(.NET 콘솔 앱, 웹 앱, 클래스 라이브러리 등), 포함된 파일 목록, 빌드 설정, 참조하는 라이브러리(NuGet 패키지 포함) 등을 포함</li>
<li>XML 기반 파일이며, Visual Studio에서 편집하거나 직접 편집할 수 있음</li>
<li>내부에 <code>&lt;PackageReference&gt;</code> 요소를 사용해서 NuGet 정보를 관리함</li>
<li>프로젝트 유형에 따라 확장자가 달라짐
<ul>
<li>C# 프로젝트: <code>.csproj</code></li>
<li>C++ 프로젝트: <code>.vcxproj</code></li>
<li>Visual Basic 프로젝트: <code>.vbproj</code></li>
</ul></li>
</ul>
</section>
<section id="기타-중요한-파일들-프로젝트-내" class="level4">
<h4 class="anchored" data-anchor-id="기타-중요한-파일들-프로젝트-내">기타 중요한 파일들 (프로젝트 내):</h4>
<ul>
<li>소스 코드 파일 (.cs, .vb, .cpp, .h 등): 실제 프로그램 코드를 포함하는 파일입니다.</li>
<li>리소스 파일 (.resx, 이미지 파일 등): 이미지, 문자열, 아이콘 등 애플리케이션에 사용되는 리소스를 포함하는 파일입니다.</li>
<li>구성 파일 (app.config, web.config, appsettings.json 등): 애플리케이션의 설정 정보를 포함하는 파일입니다.</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 39%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">파일 확장자</th>
<th style="text-align: left;">설명</th>
<th style="text-align: left;">위치</th>
<th style="text-align: left;">버전 관리</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>.sln</code></td>
<td style="text-align: left;">솔루션 구성 정보 (프로젝트 목록, 빌드 설정 등)</td>
<td style="text-align: left;">솔루션 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.csproj</code></td>
<td style="text-align: left;">C# 프로젝트 구성 정보</td>
<td style="text-align: left;">프로젝트 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.vcxproj</code></td>
<td style="text-align: left;">C++ 프로젝트 구성 정보</td>
<td style="text-align: left;">프로젝트 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.cs</code>, <code>.cpp</code> 등</td>
<td style="text-align: left;">소스 코드 파일</td>
<td style="text-align: left;">프로젝트 폴더/하위 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.resx</code> 등</td>
<td style="text-align: left;">리소스 파일</td>
<td style="text-align: left;">프로젝트 폴더/하위 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>app.config</code> 등</td>
<td style="text-align: left;">구성 파일 (애플리케이션 설정)</td>
<td style="text-align: left;">프로젝트 폴더/하위 폴더</td>
<td style="text-align: left;">포함</td>
</tr>
</tbody>
</table>
<p>이러한 파일들을 이해하고 관리함으로써 Visual Studio에서 프로젝트를 효과적으로 구성하고 협업 개발을 진행할 수 있습니다. 특히 <code>.sln</code>, <code>.csproj</code> 등의 파일은 버전 관리 시스템(Git 등)을 사용할 때 매우 중요하므로 주의 깊게 관리해야 합니다.</p>
<p>Visual Studio에서 디버깅 시작 및 관련 기능, 오류 처리, 디버깅 도구에 대한 설명을 한국어로 번역하고 정리했습니다.</p>
</section>
</section>
</section>
<section id="디버깅" class="level2">
<h2 class="anchored" data-anchor-id="디버깅">디버깅</h2>
<p>디버깅 및 오류 처리는 개발자에게 중요한 기술이며, Visual Studio는 프로세스를 효율적이고 효과적으로 만드는 강력한 도구 세트를 제공합니다. 중단점을 설정하고, 단계별 실행 및 조사식과 같은 디버깅 기능을 사용하고, 예외를 정상적으로 처리함으로써 코드의 문제를 보다 효율적으로 식별하고 해결할 수 있습니다. 디버깅 도구 및 특수 진단 기능은 소프트웨어 프로젝트의 품질을 유지하고 개선하는 능력을 더욱 향상시킵니다.</p>
<p>Visual Studio에서 애플리케이션 디버깅을 시작하는 방법은 다음과 같습니다.</p>
<ul>
<li><code>F5</code> 키를 눌러 애플리케이션의 기본 시작 구성으로 디버깅을 시작합니다.</li>
<li><code>Ctrl + F5</code> 키를 눌러 디버거를 연결하지 않고 디버깅을 시작합니다.
<ul>
<li>중단점에서 멈추지 않고 애플리케이션을 실행하여 보다 자연스러운 상황에서 동작을 관찰하려는 경우에 유용합니다.</li>
</ul></li>
<li><code>디버그(Debug)</code> 메뉴에서 <code>디버깅 시작(Start Debugging)</code>을 선택하거나, 도구 모음에서 <code>디버깅 시작(Start Debugging)</code> 버튼을 클릭합니다.</li>
</ul>
<section id="디버깅-기능" class="level3">
<h3 class="anchored" data-anchor-id="디버깅-기능">디버깅 기능</h3>
<p>애플리케이션이 디버그 모드에서 실행되면 Visual Studio는 문제 분석 및 해결에 도움이 되는 여러 가지 디버깅 기능을 제공합니다.</p>
<section id="중단점-및-단계별-실행" class="level4">
<h4 class="anchored" data-anchor-id="중단점-및-단계별-실행">중단점 및 단계별 실행</h4>
<ul>
<li>한 단계씩 코드 진행(Step Into, F11): 메서드 또는 함수 호출 내부로 들어가 해당 메서드 내의 첫 번째 코드 줄로 이동합니다.</li>
<li>프로시저 단위 실행(Step Over, F10): 메서드 또는 함수 호출 내부로 들어가지 않고 실행합니다. 디버거는 현재 메서드의 다음 줄로 이동합니다.</li>
<li>프로시저 나가기(Step Out, Shift + F11): 메서드 내부로 들어간 후 호출자 메서드로 돌아가려는 경우 이 작업을 사용합니다.</li>
<li>커서까지 실행(Run to Cursor, Ctrl + F10): 코드 줄에 커서를 놓으면 이 명령은 해당 줄에 도달할 때까지 프로그램 실행을 계속합니다.</li>
</ul>
</section>
<section id="조사식-및-로컬" class="level4">
<h4 class="anchored" data-anchor-id="조사식-및-로컬">조사식 및 로컬</h4>
<ul>
<li>조사식(Watches): 코드 단계를 진행하면서 변수 또는 식의 값을 모니터링하기 위해 조사식 창에 추가할 수 있습니다.</li>
<li>로컬(Locals): 로컬 창에는 현재 범위 내의 로컬 변수에 대한 정보가 표시됩니다.</li>
</ul>
</section>
<section id="직접-실행-창immediate-window" class="level4">
<h4 class="anchored" data-anchor-id="직접-실행-창immediate-window">직접 실행 창(Immediate Window)</h4>
<p>직접 실행 창을 사용하면 디버깅 중에 임의의 코드를 실행하고 변수를 검사할 수 있습니다. 식을 테스트하고 코드 조각을 빠르게 평가하는 데 특히 유용합니다.</p>
</section>
<section id="호출-스택call-stack" class="level4">
<h4 class="anchored" data-anchor-id="호출-스택call-stack">호출 스택(Call Stack)</h4>
<p>호출 스택 창에는 코드의 현재 지점으로 이어진 메서드 및 함수의 호출 계층 구조가 표시됩니다. 호출 스택을 탐색하여 실행 흐름을 이해할 수 있습니다.</p>
</section>
<section id="디버깅-창" class="level4">
<h4 class="anchored" data-anchor-id="디버깅-창">디버깅 창</h4>
<p>Visual Studio는 출력 창, 디버그 출력 창 및 직접 실행 창과 같은 다양한 디버깅 창을 제공합니다. 이러한 창에는 디버깅에 도움이 될 수 있는 추가 정보, 로그 및 출력이 표시됩니다.</p>
</section>
</section>
<section id="디버깅-도구" class="level3">
<h3 class="anchored" data-anchor-id="디버깅-도구">디버깅 도구</h3>
<ul>
<li>진단 도구, 메모리 사용량, CPU 사용량 및 애플리케이션 성능에 대한 통찰력을 제공</li>
<li>성능 프로파일링, 애플리케이션 성능을 분석하고 병목 현상을 식별하기 위한 프로파일링 도구가 포함되어 있음</li>
<li>IntelliTrace, 프로그램 실행 기록을 기록하여 과거에 발생한 문제를 디버깅할 수 있음</li>
<li>코드 분석, 정적 코드 분석 도구를 사용하여 잠재적인 문제 및 코드 품질 개선 사항을 식별할 수 있음</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>