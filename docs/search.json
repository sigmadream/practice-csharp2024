[
  {
    "objectID": "notes/03.html",
    "href": "notes/03.html",
    "title": "Value, Ref, Types",
    "section": "",
    "text": "C#은 강력한 형식 시스템을 가진 언어로, 데이터의 종류를 명확하게 구분하여 안정적인 프로그래밍을 지원합니다. C#의 모든 형식은 값 형식(Value Types) 또는 참조 형식(Reference Types) 중 하나에 속합니다.\n\n\n값 형식은 데이터를 직접 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 복사본이 생성되어 저장됩니다. 값 형식의 데이터는 메모리의 스택(Stack) 영역에 저장, 스택은 비교적 빠르고 크기가 제한된 메모리 영역, 함수 호출과 반환에 따라 메모리가 자동으로 관리됩니다.\nint a = 10;\nint b = a; // b에 a 값이 '복사'되어 들어감, a가 10에서 다른 값으로 바뀌더라도 b에는 영향 없음\n\n숫자 데이터 형식:\n\n정수 계열: sbyte, byte, short, ushort, int, uint, long, ulong\n실수 계열: float, double, decimal\n\n문자 형식: char (유니코드 문자 하나)\n논리 형식: bool (true 또는 false)\n열거 형식 (enum): 명명된 상수 집합을 정의하는 형식.\n구조체 (struct): 사용자 정의 값 형식. 여러 개의 값 형식을 묶어서 하나의 복합적인 데이터 형식을 만들 수 있습니다.\n\n\n\n\n참조 형식은 데이터가 저장된 메모리 주소를 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 주소가 복사되어 저장됩니다. 따라서 여러 변수가 동일한 데이터를 참조할 수 있습니다. 참조 형식의 데이터는 메모리의 힙(Heap) 영역에 저장, 힙은 스택보다 크기가 크지만, 메모리 관리를 프로그래머가 어느 정도 신경 써야합니다(가비지 컬렉터가 자동적으로 관리).\nstring s1 = \"Hello\";\nstring s2 = s1; \n// s2에는 s1과 동일한 \"Hello\"라는 문자열 객체의 참조가 복사됨, s1이나 s2 중 하나를 변경하면,(string은 불변(Immutable) 특성을 갖지만)\n// 새로운 문자열 객체가 생성되는 등의 과정에서 참조가 달라질 수 있음\n\n문자열 형식: string (유니코드 문자열)\nobject 형식: 모든 형식의 조상 형식. 모든 값 형식과 참조 형식은 object 형식으로 암시적 변환이 가능\n클래스 (class): 사용자 정의 참조 형식. 객체 지향 프로그래밍의 핵심 요소\n인터페이스 (interface): 메서드 시그니처의 집합을 정의하는 형식\n배열 (array): 동일한 형식의 데이터들을 연속적으로 저장하는 형식\n델리게이트 (delegate): 메서드를 참조하는 형식\n\n\n\n\n\n\nusing System;\n\npublic struct MyStruct\n{\n    public int Value;\n}\n\npublic class MyClass\n{\n    public int Value;\n}\n\nclass Program\n{\n    static void Main()\n    {\n        // 1. 구조체 (값 형식)\n        MyStruct s1 = new MyStruct { Value = 10 };\n        MyStruct s2 = s1;   // 값 복사\n        s2.Value = 20;\n\n        Console.WriteLine($\"s1.Value = {s1.Value}\"); // 10\n        Console.WriteLine($\"s2.Value = {s2.Value}\"); // 20\n\n        // 2. 클래스 (참조 형식)\n        MyClass c1 = new MyClass { Value = 10 };\n        MyClass c2 = c1;    // 참조 복사\n        c2.Value = 20;\n\n        Console.WriteLine($\"c1.Value = {c1.Value}\"); // 20\n        Console.WriteLine($\"c2.Value = {c2.Value}\"); // 20\n    }\n}\n“값 형식 안에도 참조가 들어갈 수 있다”는 점을 직접 실험해 보면, 단순히 “값 형식=스택, 참조 형식=힙”이라고 끝나는 게 아니라는 것을 확인 할 수 있습니다. PersonStruct는 분명히 값 형식이지만, 내부에 string(참조 형식)을 가지고 있으므로 1) 문자열 자체는 힙에 저장, 2) 구조체 안의 Name 필드는 문자열 객체의 주소를 값으로 갖고 있는 형태입니다.\npublic struct PersonStruct\n{\n    public string Name; // 참조 형식 필드\n    public int Age;\n}\n\n\n\n\n인라인(Inline) 할당, Escape Analysis\n\nC#/.NET이 내부적으로 Escape Analysis(값이 스택 범위를 벗어나는지 분석)를 해서 구조체를 최적화하거나, 때로는 힙 대신 스택에 할당할 수도 있음(C# 7 이상, 일부 시나리오)\n이런 최적화는 코드 레벨에서 바로 체감하기 어렵지만, 런타임의 최적화 원리를 이해해두면 좋음\n\n디버거에서 변수 관찰\n\nVisual Studio 또는 VS Code 디버깅 기능 사용\n브레이크포인트를 걸고, 지역 변수와 힙에 있는 객체(참조 형식)를 “Autos”나 “Locals” 창에서 확인\n스택 프레임을 확인하며, 값 형식이 어떻게 스택에 놓이는지, 참조 형식은 어디에 놓이는지를 눈으로 보면서 익힘\n코드를 디버그 모드로 실행하여 s1, s2, c1, c2 변수가 가리키는 대상을 확인\n\ns2는 새로운 값(20)을 가지지만, s1은 여전히 10을 유지하고 있음을 확인할 수 있음(값 복사)\nc2 값을 변경하면, c1도 바뀌는 것을 볼 수 있음(동일 객체 참조)\n\n\nIL(중간 언어) 코드 확인\n\nC# 코드는 .NET의 중간 언어(IL, Intermediate Language)로 컴파일됨\nIL 디컴파일러(예: ILSpy, dotPeek)를 사용해 대입 시 박싱/언박싱이 일어나는지, 값 복사가 어떻게 구현되는지 등을 확인할 수 있음\nIL 코드를 보면 stloc, ldloc 등 명령어로 스택에 변수가 어떻게 로드/저장되는지 이해가 가능해짐\n\n메모리 분석 도구 사용\n\ndotMemory, Visual Studio 진단 도구(Diagnostic Tools) 등 메모리 분석 도구를 활용\n프로그램 실행 중 힙에 어떤 객체가 얼마만큼 올라가 있고, GC가 언제 일어나는지 추적할 수 있음\n값 형식은 힙에 직접 올라가지 않지만(참조 형식의 필드로 쓰인 경우는 내부적으로 참조로 연결됨), 참조 형식이 힙에서 어떻게 배치되는지 실제 현황을 확인 가능\n\nSpan&lt;T&gt;, ref struct 등\n\n최신 C# 문법에서는 스택만을 대상으로 하는 구조(ref struct)가 등장(Span&lt;T&gt;, ReadOnlySpan&lt;T&gt; 등)\n이런 타입들은 스택에만 존재해야 하며, 힙에 들어갈 수 없도록 CLR/C# 컴파일러가 제약을 걸어놓음\n\n\n\n\n\n\nSpan&lt;T&gt;와 ref struct는 성능과 안전성을 높이기 위해 도입된 중요한 기능들입니다. 이들은 특히 메모리 관리 및 데이터 처리 방식에서 큰 영향을 줍니다.\n\n\nC#에서 배열이나 문자열과 같은 데이터는 메모리상에서 연속적으로 저장되는 경향이 있습니다. 기존에는 이 데이터를 처리하기 위해 배열의 일부를 복사하거나, 데이터를 수정하기 위해 새로운 배열을 할당해야 했습니다. 이러한 작업은 불필요한 메모리 할당과 복사를 초래하여 성능 저하를 유발했습니다. Span&lt;T&gt;는 메모리 연속적인 영역에 대한 뷰(View)를 제공합니다. 즉, 실제 데이터를 복사하지 않고도 연속적인 메모리 영역의 일부를 참조하고 조작할 수 있게 해줍니다. - 주요 이점 - Zero-copy: 메모리 복사 없이 데이터를 참조하므로 성능이 크게 향상됩니다. - 다양한 메모리 원본 지원: 배열, 문자열, stackalloc, 네이티브 메모리 등 다양한 메모리 원본에서 Span&lt;T&gt;를 생성할 수 있습니다. - 안전한 접근: Span&lt;T&gt;는 범위 검사를 수행하여 안전하지 않은 메모리 접근을 방지합니다. - 사용 예시: - 문자열의 일부를 파싱하거나 특정 부분을 수정하는 경우 - 네트워크나 파일에서 받은 데이터를 처리하는 경우 - 고성능 수학 라이브러리에서 배열을 조작하는 경우\n\n\n\nC#의 구조체는 값 형식으로, 기본적으로 스택에 할당됩니다. 하지만 구조체 내에 참조 형식이 포함되어 있거나, 특정 경우에는 힙에 할당될 수 있습니다. 이러한 경우, 구조체의 생명주기가 복잡해지고 GC(Garbage Collector)의 부담을 증가시킬 수 있습니다. ref struct는 구조체가 반드시 스택에 할당되도록 강제합니다. 또한, ref struct는 일반적인 구조체와 달리 힙에 할당될 수 없고, 박싱(Boxing)이나 인터페이스 구현이 제한되는 등 몇 가지 제약 사항을 가지고 있습니다.\n\n주요 이점:\n\n스택 할당 강제: 항상 스택에 할당되어 GC의 부담을 줄이고, 메모리 할당 및 해제 비용을 최적화합니다.\n안전한 사용: 힙에 할당될 수 없으므로 포인터 관련 위험이 줄어들고, Span&lt;T&gt;와 같은 구조체를 안전하게 사용할 수 있습니다.\n성능 향상: 메모리 할당과 해제 비용을 줄여 전반적인 성능을 향상시킵니다.\n\n사용 예시:\n\nSpan&lt;T&gt;와 같이 메모리 안전에 민감한 구조체를 정의할 때\n메모리 관리를 명확하게 제어해야 하는 고성능 코드 작성 시\nGC의 영향을 최소화해야 하는 코드를 작성할 때\n\n\n\n\n\nSpan&lt;T&gt;와 ref struct와 유사한 기능 또는 비슷한 목적을 달성할 수 있는 다른 방법들이 존재합니다. 하지만 이들은 Span&lt;T&gt;와 ref struct만큼 효율적이거나 안전하지 않을 수 있으며, 특정 제약 사항을 가지고 있을 수 있습니다.\n\n배열 복사: 가장 기본적인 방법으로, 배열의 일부를 새로운 배열로 복사하여 데이터를 처리합니다.\n\n문제점: 메모리 할당 및 복사 비용이 발생하여 성능 저하를 유발합니다.\n사용 예시: 간단한 데이터 복사가 필요한 경우, 원본 데이터가 변경되지 않아야 하는 경우\n\nArraySegment&lt;T&gt;: 배열의 일부를 표현하는 구조체입니다.\n\n장점: 메모리 복사 없이 배열의 일부분을 표현할 수 있습니다.\n문제점: Span&lt;T&gt;처럼 다양한 메모리 원본을 지원하지 않으며, 성능 최적화가 덜 되어 있습니다.\n사용 예시: 배열의 일부를 메서드에 전달하거나, 배열의 일부를 처리하는 경우\n\nunsafe 키워드 및 포인터: unsafe 키워드를 사용하여 포인터를 직접 조작할 수 있습니다.\n\n장점: 매우 높은 수준의 성능 최적화가 가능합니다.\n문제점: 메모리 안전을 보장하기 어려우며, 포인터 조작 오류 시 프로그램이 불안정해질 수 있습니다.\n사용 예시: 극도로 높은 성능이 요구되는 특정 작업, 네이티브 메모리 조작이 필요한 경우\n\nMemory&lt;T&gt;: 메모리 연속된 영역에 대한 추상화된 표현입니다.\n\n장점: Span&lt;T&gt;와 유사하게 다양한 메모리 원본에서 동작하며, Span&lt;T&gt;로 변환할 수 있습니다.\n문제점: Span&lt;T&gt;처럼 스택에 할당되는 값 형식이 아니라 힙에 할당될 수 있는 참조 형식이므로 제약 사항이 존재합니다.\n사용 예시: 비동기 작업, 파일 및 네트워크 I/O와 같이 메모리 관리 및 수명이 명확하지 않은 상황\n\nStringBuilder의 GetChunks(): 문자열을 직접 조작하는 대신 StringBuilder를 사용하고 GetChunks()를 호출하면 ReadOnlyMemory&lt;char&gt;를 얻을 수 있습니다.\n\n장점: 문자열을 더 효율적으로 조작할 수 있습니다.\n문제점: 여전히 추가 복사가 발생할 수 있습니다.\n사용 예시: 문자열을 수정하고 파싱하는 경우\n\n\n\n\n\n\n일반 구조체: 기본적으로 스택에 할당되지만, 다음과 같은 제약 사항이 있습니다.\n\n참조 형식 멤버를 포함할 수 있으며, 박싱될 수 있고, 힙에 할당될 수 있습니다. 인터페이스를 구현할 수 있습니다.\n문제점: GC 부담을 증가시키고, 의도치 않게 힙에 할당될 수 있어 메모리 관리가 복잡해질 수 있습니다.\n사용 예시: 일반적인 값 형식으로 데이터를 저장할 때\n\n\n\n\n\n\n\n\n\n\n\n\n\n기능\nSpan&lt;T&gt;\nref struct\n\n\n\n\n주요 목적\n메모리 복사 없이 연속적인 메모리 영역에 효율적으로 접근\n구조체가 항상 스택에 할당되도록 강제하여 메모리 관리를 최적화\n\n\n대안\n배열 복사, ArraySegment&lt;T&gt;, unsafe 키워드 및 포인터, Memory&lt;T&gt;, StringBuilder의 GetChunks()\n일반적인 구조체\n\n\n장점\n제로 카피, 다양한 메모리 원본 지원, 안전한 접근\n스택 할당 강제, 메모리 안전성 향상, GC 부담 감소\n\n\n단점\n특정 상황에서 다소 복잡하게 느껴질 수 있음\n박싱 불가, 인터페이스 구현 불가, 힙 할당 불가 등 제약 사항 존재\n\n\n유사 기능 차이\n대안들은 메모리 복사 또는 메모리 관리의 안전성이 떨어짐. 특정 용도에 한정됨\n대안은 메모리 관리, GC 부담, 특정 제약 사항에서 차이 발생\n\n\n사용 권장\n고성능 데이터 처리, 메모리 조작, 파싱, I/O\n메모리 안전을 보장해야 하는 구조체, 고성능 코드, GC 영향을 최소화해야 하는 코드 작성 시\n\n\n\n네, Span&lt;T&gt;와 ref struct를 사용했을 때 성능 및 안전성 측면에서 얻을 수 있는 장점을 보여주는 간단한 예제를 C#으로 작성해 보겠습니다.\n예제 1: Span&lt;T&gt;를 사용한 문자열 파싱 성능 향상\nusing System;\nusing System.Diagnostics;\n\npublic class SpanExample\n{\n    public static void Main(string[] args)\n    {\n        string largeString = new string('A', 1000000) + \",12345,67890\"; // 큰 문자열 생성\n\n        // 일반적인 문자열 처리 방법 (Substring)\n        Stopwatch sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n            string sub1 = largeString.Substring(largeString.IndexOf(',') + 1);\n            string sub2 = sub1.Substring(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Substring Elapsed: {sw.ElapsedMilliseconds} ms\");\n\n        // Span&lt;T&gt;을 사용한 문자열 처리 방법\n        sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n             ReadOnlySpan&lt;char&gt; span = largeString.AsSpan();\n             ReadOnlySpan&lt;char&gt; sub1 = span.Slice(span.IndexOf(',') + 1);\n             ReadOnlySpan&lt;char&gt; sub2 = sub1.Slice(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Span Elapsed: {sw.ElapsedMilliseconds} ms\");\n    }\n}\n설명:\n\n큰 문자열 생성: 테스트를 위해 큰 문자열을 생성합니다.\n일반적인 문자열 처리: Substring을 사용하여 문자열을 자르고 파싱합니다.\nSpan&lt;T&gt;를 사용한 문자열 처리:\n\nAsSpan()을 사용하여 문자열을 ReadOnlySpan&lt;char&gt;로 변환합니다.\nSlice()를 사용하여 Span&lt;T&gt;의 일부분을 참조합니다.\n메모리 복사 없이 Span&lt;T&gt;을 이용하여 문자열을 파싱합니다.\n\n성능 측정: Stopwatch를 사용하여 각 방법의 실행 시간을 측정합니다.\n\n실행 결과:\n일반적으로 Substring을 사용하는 방법보다 Span&lt;T&gt;을 사용하는 방법이 훨씬 빠른 것을 확인할 수 있습니다. 이는 Span&lt;T&gt;이 메모리 복사를 하지 않고 원본 문자열의 뷰를 제공하기 때문입니다.\n예제 2: ref struct를 사용한 안전한 스택 기반 구조체\nusing System;\n\npublic class RefStructExample\n{\n     // ref struct 예시\n    public ref struct StackBasedData\n    {\n        public int Value;\n        public StackBasedData(int value)\n        {\n            Value = value;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        StackBasedData data = new StackBasedData(10); // 스택에 할당됨\n\n        // 오류: ref struct는 힙에 할당될 수 없으므로 아래와 같이 사용할 수 없음\n        // object boxedData = data;\n\n        // ref struct를 인수로 받는 메서드 호출\n         PrintStackBasedData(data);\n\n        // ref struct를 반환하는 메서드 호출\n        ref StackBasedData returnedData = ref GetStackBasedData(data);\n        Console.WriteLine($\"Returned Data: {returnedData.Value}\");\n        \n    }\n\n    public static void PrintStackBasedData(StackBasedData data)\n    {\n        Console.WriteLine($\"Data: {data.Value}\");\n    }\n\n    public static ref StackBasedData GetStackBasedData(StackBasedData data)\n    {\n        return ref data; // ref 반환\n    }\n\n}\n\n네, `Span&lt;T&gt;`와 `ref struct`를 사용했을 때 성능 및 안전성 측면에서 얻을 수 있는 장점을 보여주는 간단한 예제를 C#으로 작성해 보겠습니다.\n\n예제 1: `Span&lt;T&gt;`를 사용한 문자열 파싱 성능 향상\n\n```csharp\nusing System;\nusing System.Diagnostics;\n\npublic class SpanExample\n{\n    public static void Main(string[] args)\n    {\n        string largeString = new string('A', 1000000) + \",12345,67890\"; // 큰 문자열 생성\n\n        // 일반적인 문자열 처리 방법 (Substring)\n        Stopwatch sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n            string sub1 = largeString.Substring(largeString.IndexOf(',') + 1);\n            string sub2 = sub1.Substring(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Substring Elapsed: {sw.ElapsedMilliseconds} ms\");\n\n        // Span&lt;T&gt;을 사용한 문자열 처리 방법\n        sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n             ReadOnlySpan&lt;char&gt; span = largeString.AsSpan();\n             ReadOnlySpan&lt;char&gt; sub1 = span.Slice(span.IndexOf(',') + 1);\n             ReadOnlySpan&lt;char&gt; sub2 = sub1.Slice(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Span Elapsed: {sw.ElapsedMilliseconds} ms\");\n    }\n}\n\npublic class RefStructExample\n{\n     // ref struct 예시\n    public ref struct StackBasedData\n    {\n        public int Value;\n        public StackBasedData(int value)\n        {\n            Value = value;\n        }\n    }\n    public static void Main(string[] args)\n    {\n        StackBasedData data = new StackBasedData(10); // 스택에 할당됨\n\n        // 오류: ref struct는 힙에 할당될 수 없으므로 아래와 같이 사용할 수 없음\n        // object boxedData = data;\n\n        // ref struct를 인수로 받는 메서드 호출\n         PrintStackBasedData(data);\n\n        // ref struct를 반환하는 메서드 호출\n        ref StackBasedData returnedData = ref GetStackBasedData(data);\n        Console.WriteLine($\"Returned Data: {returnedData.Value}\");\n        \n    }\n\n    public static void PrintStackBasedData(StackBasedData data)\n    {\n        Console.WriteLine($\"Data: {data.Value}\");\n    }\n\n    public static ref StackBasedData GetStackBasedData(StackBasedData data)\n    {\n        return ref data; // ref 반환\n    }\n\n}",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#c의-형식types",
    "href": "notes/03.html#c의-형식types",
    "title": "Value, Ref, Types",
    "section": "",
    "text": "C#은 강력한 형식 시스템을 가진 언어로, 데이터의 종류를 명확하게 구분하여 안정적인 프로그래밍을 지원합니다. C#의 모든 형식은 값 형식(Value Types) 또는 참조 형식(Reference Types) 중 하나에 속합니다.\n\n\n값 형식은 데이터를 직접 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 복사본이 생성되어 저장됩니다. 값 형식의 데이터는 메모리의 스택(Stack) 영역에 저장, 스택은 비교적 빠르고 크기가 제한된 메모리 영역, 함수 호출과 반환에 따라 메모리가 자동으로 관리됩니다.\nint a = 10;\nint b = a; // b에 a 값이 '복사'되어 들어감, a가 10에서 다른 값으로 바뀌더라도 b에는 영향 없음\n\n숫자 데이터 형식:\n\n정수 계열: sbyte, byte, short, ushort, int, uint, long, ulong\n실수 계열: float, double, decimal\n\n문자 형식: char (유니코드 문자 하나)\n논리 형식: bool (true 또는 false)\n열거 형식 (enum): 명명된 상수 집합을 정의하는 형식.\n구조체 (struct): 사용자 정의 값 형식. 여러 개의 값 형식을 묶어서 하나의 복합적인 데이터 형식을 만들 수 있습니다.\n\n\n\n\n참조 형식은 데이터가 저장된 메모리 주소를 저장하는 형식을 말합니다. 변수에 값을 할당하면 데이터의 주소가 복사되어 저장됩니다. 따라서 여러 변수가 동일한 데이터를 참조할 수 있습니다. 참조 형식의 데이터는 메모리의 힙(Heap) 영역에 저장, 힙은 스택보다 크기가 크지만, 메모리 관리를 프로그래머가 어느 정도 신경 써야합니다(가비지 컬렉터가 자동적으로 관리).\nstring s1 = \"Hello\";\nstring s2 = s1; \n// s2에는 s1과 동일한 \"Hello\"라는 문자열 객체의 참조가 복사됨, s1이나 s2 중 하나를 변경하면,(string은 불변(Immutable) 특성을 갖지만)\n// 새로운 문자열 객체가 생성되는 등의 과정에서 참조가 달라질 수 있음\n\n문자열 형식: string (유니코드 문자열)\nobject 형식: 모든 형식의 조상 형식. 모든 값 형식과 참조 형식은 object 형식으로 암시적 변환이 가능\n클래스 (class): 사용자 정의 참조 형식. 객체 지향 프로그래밍의 핵심 요소\n인터페이스 (interface): 메서드 시그니처의 집합을 정의하는 형식\n배열 (array): 동일한 형식의 데이터들을 연속적으로 저장하는 형식\n델리게이트 (delegate): 메서드를 참조하는 형식\n\n\n\n\n\n\nusing System;\n\npublic struct MyStruct\n{\n    public int Value;\n}\n\npublic class MyClass\n{\n    public int Value;\n}\n\nclass Program\n{\n    static void Main()\n    {\n        // 1. 구조체 (값 형식)\n        MyStruct s1 = new MyStruct { Value = 10 };\n        MyStruct s2 = s1;   // 값 복사\n        s2.Value = 20;\n\n        Console.WriteLine($\"s1.Value = {s1.Value}\"); // 10\n        Console.WriteLine($\"s2.Value = {s2.Value}\"); // 20\n\n        // 2. 클래스 (참조 형식)\n        MyClass c1 = new MyClass { Value = 10 };\n        MyClass c2 = c1;    // 참조 복사\n        c2.Value = 20;\n\n        Console.WriteLine($\"c1.Value = {c1.Value}\"); // 20\n        Console.WriteLine($\"c2.Value = {c2.Value}\"); // 20\n    }\n}\n“값 형식 안에도 참조가 들어갈 수 있다”는 점을 직접 실험해 보면, 단순히 “값 형식=스택, 참조 형식=힙”이라고 끝나는 게 아니라는 것을 확인 할 수 있습니다. PersonStruct는 분명히 값 형식이지만, 내부에 string(참조 형식)을 가지고 있으므로 1) 문자열 자체는 힙에 저장, 2) 구조체 안의 Name 필드는 문자열 객체의 주소를 값으로 갖고 있는 형태입니다.\npublic struct PersonStruct\n{\n    public string Name; // 참조 형식 필드\n    public int Age;\n}\n\n\n\n\n인라인(Inline) 할당, Escape Analysis\n\nC#/.NET이 내부적으로 Escape Analysis(값이 스택 범위를 벗어나는지 분석)를 해서 구조체를 최적화하거나, 때로는 힙 대신 스택에 할당할 수도 있음(C# 7 이상, 일부 시나리오)\n이런 최적화는 코드 레벨에서 바로 체감하기 어렵지만, 런타임의 최적화 원리를 이해해두면 좋음\n\n디버거에서 변수 관찰\n\nVisual Studio 또는 VS Code 디버깅 기능 사용\n브레이크포인트를 걸고, 지역 변수와 힙에 있는 객체(참조 형식)를 “Autos”나 “Locals” 창에서 확인\n스택 프레임을 확인하며, 값 형식이 어떻게 스택에 놓이는지, 참조 형식은 어디에 놓이는지를 눈으로 보면서 익힘\n코드를 디버그 모드로 실행하여 s1, s2, c1, c2 변수가 가리키는 대상을 확인\n\ns2는 새로운 값(20)을 가지지만, s1은 여전히 10을 유지하고 있음을 확인할 수 있음(값 복사)\nc2 값을 변경하면, c1도 바뀌는 것을 볼 수 있음(동일 객체 참조)\n\n\nIL(중간 언어) 코드 확인\n\nC# 코드는 .NET의 중간 언어(IL, Intermediate Language)로 컴파일됨\nIL 디컴파일러(예: ILSpy, dotPeek)를 사용해 대입 시 박싱/언박싱이 일어나는지, 값 복사가 어떻게 구현되는지 등을 확인할 수 있음\nIL 코드를 보면 stloc, ldloc 등 명령어로 스택에 변수가 어떻게 로드/저장되는지 이해가 가능해짐\n\n메모리 분석 도구 사용\n\ndotMemory, Visual Studio 진단 도구(Diagnostic Tools) 등 메모리 분석 도구를 활용\n프로그램 실행 중 힙에 어떤 객체가 얼마만큼 올라가 있고, GC가 언제 일어나는지 추적할 수 있음\n값 형식은 힙에 직접 올라가지 않지만(참조 형식의 필드로 쓰인 경우는 내부적으로 참조로 연결됨), 참조 형식이 힙에서 어떻게 배치되는지 실제 현황을 확인 가능\n\nSpan&lt;T&gt;, ref struct 등\n\n최신 C# 문법에서는 스택만을 대상으로 하는 구조(ref struct)가 등장(Span&lt;T&gt;, ReadOnlySpan&lt;T&gt; 등)\n이런 타입들은 스택에만 존재해야 하며, 힙에 들어갈 수 없도록 CLR/C# 컴파일러가 제약을 걸어놓음\n\n\n\n\n\n\nSpan&lt;T&gt;와 ref struct는 성능과 안전성을 높이기 위해 도입된 중요한 기능들입니다. 이들은 특히 메모리 관리 및 데이터 처리 방식에서 큰 영향을 줍니다.\n\n\nC#에서 배열이나 문자열과 같은 데이터는 메모리상에서 연속적으로 저장되는 경향이 있습니다. 기존에는 이 데이터를 처리하기 위해 배열의 일부를 복사하거나, 데이터를 수정하기 위해 새로운 배열을 할당해야 했습니다. 이러한 작업은 불필요한 메모리 할당과 복사를 초래하여 성능 저하를 유발했습니다. Span&lt;T&gt;는 메모리 연속적인 영역에 대한 뷰(View)를 제공합니다. 즉, 실제 데이터를 복사하지 않고도 연속적인 메모리 영역의 일부를 참조하고 조작할 수 있게 해줍니다. - 주요 이점 - Zero-copy: 메모리 복사 없이 데이터를 참조하므로 성능이 크게 향상됩니다. - 다양한 메모리 원본 지원: 배열, 문자열, stackalloc, 네이티브 메모리 등 다양한 메모리 원본에서 Span&lt;T&gt;를 생성할 수 있습니다. - 안전한 접근: Span&lt;T&gt;는 범위 검사를 수행하여 안전하지 않은 메모리 접근을 방지합니다. - 사용 예시: - 문자열의 일부를 파싱하거나 특정 부분을 수정하는 경우 - 네트워크나 파일에서 받은 데이터를 처리하는 경우 - 고성능 수학 라이브러리에서 배열을 조작하는 경우\n\n\n\nC#의 구조체는 값 형식으로, 기본적으로 스택에 할당됩니다. 하지만 구조체 내에 참조 형식이 포함되어 있거나, 특정 경우에는 힙에 할당될 수 있습니다. 이러한 경우, 구조체의 생명주기가 복잡해지고 GC(Garbage Collector)의 부담을 증가시킬 수 있습니다. ref struct는 구조체가 반드시 스택에 할당되도록 강제합니다. 또한, ref struct는 일반적인 구조체와 달리 힙에 할당될 수 없고, 박싱(Boxing)이나 인터페이스 구현이 제한되는 등 몇 가지 제약 사항을 가지고 있습니다.\n\n주요 이점:\n\n스택 할당 강제: 항상 스택에 할당되어 GC의 부담을 줄이고, 메모리 할당 및 해제 비용을 최적화합니다.\n안전한 사용: 힙에 할당될 수 없으므로 포인터 관련 위험이 줄어들고, Span&lt;T&gt;와 같은 구조체를 안전하게 사용할 수 있습니다.\n성능 향상: 메모리 할당과 해제 비용을 줄여 전반적인 성능을 향상시킵니다.\n\n사용 예시:\n\nSpan&lt;T&gt;와 같이 메모리 안전에 민감한 구조체를 정의할 때\n메모리 관리를 명확하게 제어해야 하는 고성능 코드 작성 시\nGC의 영향을 최소화해야 하는 코드를 작성할 때\n\n\n\n\n\nSpan&lt;T&gt;와 ref struct와 유사한 기능 또는 비슷한 목적을 달성할 수 있는 다른 방법들이 존재합니다. 하지만 이들은 Span&lt;T&gt;와 ref struct만큼 효율적이거나 안전하지 않을 수 있으며, 특정 제약 사항을 가지고 있을 수 있습니다.\n\n배열 복사: 가장 기본적인 방법으로, 배열의 일부를 새로운 배열로 복사하여 데이터를 처리합니다.\n\n문제점: 메모리 할당 및 복사 비용이 발생하여 성능 저하를 유발합니다.\n사용 예시: 간단한 데이터 복사가 필요한 경우, 원본 데이터가 변경되지 않아야 하는 경우\n\nArraySegment&lt;T&gt;: 배열의 일부를 표현하는 구조체입니다.\n\n장점: 메모리 복사 없이 배열의 일부분을 표현할 수 있습니다.\n문제점: Span&lt;T&gt;처럼 다양한 메모리 원본을 지원하지 않으며, 성능 최적화가 덜 되어 있습니다.\n사용 예시: 배열의 일부를 메서드에 전달하거나, 배열의 일부를 처리하는 경우\n\nunsafe 키워드 및 포인터: unsafe 키워드를 사용하여 포인터를 직접 조작할 수 있습니다.\n\n장점: 매우 높은 수준의 성능 최적화가 가능합니다.\n문제점: 메모리 안전을 보장하기 어려우며, 포인터 조작 오류 시 프로그램이 불안정해질 수 있습니다.\n사용 예시: 극도로 높은 성능이 요구되는 특정 작업, 네이티브 메모리 조작이 필요한 경우\n\nMemory&lt;T&gt;: 메모리 연속된 영역에 대한 추상화된 표현입니다.\n\n장점: Span&lt;T&gt;와 유사하게 다양한 메모리 원본에서 동작하며, Span&lt;T&gt;로 변환할 수 있습니다.\n문제점: Span&lt;T&gt;처럼 스택에 할당되는 값 형식이 아니라 힙에 할당될 수 있는 참조 형식이므로 제약 사항이 존재합니다.\n사용 예시: 비동기 작업, 파일 및 네트워크 I/O와 같이 메모리 관리 및 수명이 명확하지 않은 상황\n\nStringBuilder의 GetChunks(): 문자열을 직접 조작하는 대신 StringBuilder를 사용하고 GetChunks()를 호출하면 ReadOnlyMemory&lt;char&gt;를 얻을 수 있습니다.\n\n장점: 문자열을 더 효율적으로 조작할 수 있습니다.\n문제점: 여전히 추가 복사가 발생할 수 있습니다.\n사용 예시: 문자열을 수정하고 파싱하는 경우\n\n\n\n\n\n\n일반 구조체: 기본적으로 스택에 할당되지만, 다음과 같은 제약 사항이 있습니다.\n\n참조 형식 멤버를 포함할 수 있으며, 박싱될 수 있고, 힙에 할당될 수 있습니다. 인터페이스를 구현할 수 있습니다.\n문제점: GC 부담을 증가시키고, 의도치 않게 힙에 할당될 수 있어 메모리 관리가 복잡해질 수 있습니다.\n사용 예시: 일반적인 값 형식으로 데이터를 저장할 때\n\n\n\n\n\n\n\n\n\n\n\n\n\n기능\nSpan&lt;T&gt;\nref struct\n\n\n\n\n주요 목적\n메모리 복사 없이 연속적인 메모리 영역에 효율적으로 접근\n구조체가 항상 스택에 할당되도록 강제하여 메모리 관리를 최적화\n\n\n대안\n배열 복사, ArraySegment&lt;T&gt;, unsafe 키워드 및 포인터, Memory&lt;T&gt;, StringBuilder의 GetChunks()\n일반적인 구조체\n\n\n장점\n제로 카피, 다양한 메모리 원본 지원, 안전한 접근\n스택 할당 강제, 메모리 안전성 향상, GC 부담 감소\n\n\n단점\n특정 상황에서 다소 복잡하게 느껴질 수 있음\n박싱 불가, 인터페이스 구현 불가, 힙 할당 불가 등 제약 사항 존재\n\n\n유사 기능 차이\n대안들은 메모리 복사 또는 메모리 관리의 안전성이 떨어짐. 특정 용도에 한정됨\n대안은 메모리 관리, GC 부담, 특정 제약 사항에서 차이 발생\n\n\n사용 권장\n고성능 데이터 처리, 메모리 조작, 파싱, I/O\n메모리 안전을 보장해야 하는 구조체, 고성능 코드, GC 영향을 최소화해야 하는 코드 작성 시\n\n\n\n네, Span&lt;T&gt;와 ref struct를 사용했을 때 성능 및 안전성 측면에서 얻을 수 있는 장점을 보여주는 간단한 예제를 C#으로 작성해 보겠습니다.\n예제 1: Span&lt;T&gt;를 사용한 문자열 파싱 성능 향상\nusing System;\nusing System.Diagnostics;\n\npublic class SpanExample\n{\n    public static void Main(string[] args)\n    {\n        string largeString = new string('A', 1000000) + \",12345,67890\"; // 큰 문자열 생성\n\n        // 일반적인 문자열 처리 방법 (Substring)\n        Stopwatch sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n            string sub1 = largeString.Substring(largeString.IndexOf(',') + 1);\n            string sub2 = sub1.Substring(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Substring Elapsed: {sw.ElapsedMilliseconds} ms\");\n\n        // Span&lt;T&gt;을 사용한 문자열 처리 방법\n        sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n             ReadOnlySpan&lt;char&gt; span = largeString.AsSpan();\n             ReadOnlySpan&lt;char&gt; sub1 = span.Slice(span.IndexOf(',') + 1);\n             ReadOnlySpan&lt;char&gt; sub2 = sub1.Slice(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Span Elapsed: {sw.ElapsedMilliseconds} ms\");\n    }\n}\n설명:\n\n큰 문자열 생성: 테스트를 위해 큰 문자열을 생성합니다.\n일반적인 문자열 처리: Substring을 사용하여 문자열을 자르고 파싱합니다.\nSpan&lt;T&gt;를 사용한 문자열 처리:\n\nAsSpan()을 사용하여 문자열을 ReadOnlySpan&lt;char&gt;로 변환합니다.\nSlice()를 사용하여 Span&lt;T&gt;의 일부분을 참조합니다.\n메모리 복사 없이 Span&lt;T&gt;을 이용하여 문자열을 파싱합니다.\n\n성능 측정: Stopwatch를 사용하여 각 방법의 실행 시간을 측정합니다.\n\n실행 결과:\n일반적으로 Substring을 사용하는 방법보다 Span&lt;T&gt;을 사용하는 방법이 훨씬 빠른 것을 확인할 수 있습니다. 이는 Span&lt;T&gt;이 메모리 복사를 하지 않고 원본 문자열의 뷰를 제공하기 때문입니다.\n예제 2: ref struct를 사용한 안전한 스택 기반 구조체\nusing System;\n\npublic class RefStructExample\n{\n     // ref struct 예시\n    public ref struct StackBasedData\n    {\n        public int Value;\n        public StackBasedData(int value)\n        {\n            Value = value;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        StackBasedData data = new StackBasedData(10); // 스택에 할당됨\n\n        // 오류: ref struct는 힙에 할당될 수 없으므로 아래와 같이 사용할 수 없음\n        // object boxedData = data;\n\n        // ref struct를 인수로 받는 메서드 호출\n         PrintStackBasedData(data);\n\n        // ref struct를 반환하는 메서드 호출\n        ref StackBasedData returnedData = ref GetStackBasedData(data);\n        Console.WriteLine($\"Returned Data: {returnedData.Value}\");\n        \n    }\n\n    public static void PrintStackBasedData(StackBasedData data)\n    {\n        Console.WriteLine($\"Data: {data.Value}\");\n    }\n\n    public static ref StackBasedData GetStackBasedData(StackBasedData data)\n    {\n        return ref data; // ref 반환\n    }\n\n}\n\n네, `Span&lt;T&gt;`와 `ref struct`를 사용했을 때 성능 및 안전성 측면에서 얻을 수 있는 장점을 보여주는 간단한 예제를 C#으로 작성해 보겠습니다.\n\n예제 1: `Span&lt;T&gt;`를 사용한 문자열 파싱 성능 향상\n\n```csharp\nusing System;\nusing System.Diagnostics;\n\npublic class SpanExample\n{\n    public static void Main(string[] args)\n    {\n        string largeString = new string('A', 1000000) + \",12345,67890\"; // 큰 문자열 생성\n\n        // 일반적인 문자열 처리 방법 (Substring)\n        Stopwatch sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n            string sub1 = largeString.Substring(largeString.IndexOf(',') + 1);\n            string sub2 = sub1.Substring(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Substring Elapsed: {sw.ElapsedMilliseconds} ms\");\n\n        // Span&lt;T&gt;을 사용한 문자열 처리 방법\n        sw = Stopwatch.StartNew();\n        for (int i = 0; i &lt; 1000; i++)\n        {\n             ReadOnlySpan&lt;char&gt; span = largeString.AsSpan();\n             ReadOnlySpan&lt;char&gt; sub1 = span.Slice(span.IndexOf(',') + 1);\n             ReadOnlySpan&lt;char&gt; sub2 = sub1.Slice(sub1.IndexOf(',') + 1);\n            _ = int.Parse(sub2);\n        }\n        sw.Stop();\n        Console.WriteLine($\"Span Elapsed: {sw.ElapsedMilliseconds} ms\");\n    }\n}\n\npublic class RefStructExample\n{\n     // ref struct 예시\n    public ref struct StackBasedData\n    {\n        public int Value;\n        public StackBasedData(int value)\n        {\n            Value = value;\n        }\n    }\n    public static void Main(string[] args)\n    {\n        StackBasedData data = new StackBasedData(10); // 스택에 할당됨\n\n        // 오류: ref struct는 힙에 할당될 수 없으므로 아래와 같이 사용할 수 없음\n        // object boxedData = data;\n\n        // ref struct를 인수로 받는 메서드 호출\n         PrintStackBasedData(data);\n\n        // ref struct를 반환하는 메서드 호출\n        ref StackBasedData returnedData = ref GetStackBasedData(data);\n        Console.WriteLine($\"Returned Data: {returnedData.Value}\");\n        \n    }\n\n    public static void PrintStackBasedData(StackBasedData data)\n    {\n        Console.WriteLine($\"Data: {data.Value}\");\n    }\n\n    public static ref StackBasedData GetStackBasedData(StackBasedData data)\n    {\n        return ref data; // ref 반환\n    }\n\n}",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#박싱과-언박싱boxing-and-unboxing",
    "href": "notes/03.html#박싱과-언박싱boxing-and-unboxing",
    "title": "Value, Ref, Types",
    "section": "박싱과 언박싱(boxing and unboxing)",
    "text": "박싱과 언박싱(boxing and unboxing)\n\n박싱: 값 형식을 참조 형식인 object 형식으로 변환하는 과정, 힙에 새로운 객체를 할당하고 값 형식의 데이터를 복사\n\nint num = 123;\nobject boxed = num; // int -&gt; object로 박싱\n\n언박싱: object 형식에서 값 형식으로 다시 변환하는 과정, 힙에 저장된 데이터를 스택으로 복사\n\nobject boxedNum = 123;\nint unboxedNum = (int)boxedNum; // 언박싱: int 형식으로 명시적 캐스팅",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#문자열-다루기string-manipulation",
    "href": "notes/03.html#문자열-다루기string-manipulation",
    "title": "Value, Ref, Types",
    "section": "문자열 다루기(string manipulation)",
    "text": "문자열 다루기(string manipulation)\n\n찾기: 문자열 내에서 특정 문자 또는 문자열의 위치를 찾는 메서드(IndexOf, LastIndexOf, Contains 등)\n\nstring greeting = \"Hello World\";\nint indexOfW = greeting.IndexOf('W'); // 6\nbool hasHello = greeting.Contains(\"Hello\"); // true\n\n변형: 문자열의 내용을 변경하는 메서드(ToUpper, ToLower, Trim, Replace 등)\n\nstring sample = \"  Hello World  \";\nstring upper = sample.ToUpper(); // \"  HELLO WORLD  \"\nstring trimmed = sample.Trim();  // \"Hello World\"\nstring replaced = sample.Replace(\"World\", \"C#\"); // \"  Hello C#  \"\n\n분할: 문자열을 특정 구분자를 기준으로 여러 부분으로 나누는 메서드(Split)\n\nstring fruitList = \"Apple,Banana,Cherry\";\nstring[] fruits = fruitList.Split(',');\n// fruits[0] = \"Apple\"\n// fruits[1] = \"Banana\"\n// fruits[2] = \"Cherry\"\n\n서식: 문자열의 형식을 지정하는 방법(string.Format, 보간된 문자열 $\"\")\n\nint age = 25;\nstring name = \"홍길동\";\n\n// 1) string.Format 사용\nstring result1 = string.Format(\"이름: {0}, 나이: {1}\", name, age);\n\n// 2) 보간 문자열 사용($\"\" 또는 @$\"\")\nstring result2 = $\"이름: {name}, 나이: {age}\";",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#데이터를-가공하는-연산자operators",
    "href": "notes/03.html#데이터를-가공하는-연산자operators",
    "title": "Value, Ref, Types",
    "section": "데이터를 가공하는 연산자(operators)",
    "text": "데이터를 가공하는 연산자(operators)\n\n산술 연산자: +, -, *, /, %\n\nint x = 10;\nint y = 3;\nConsole.WriteLine(x + y); // 13\nConsole.WriteLine(x - y); // 7\nConsole.WriteLine(x * y); // 30\nConsole.WriteLine(x / y); // 3  (정수 나눗셈)\nConsole.WriteLine(x % y); // 1\n\n증가 연산자와 감소 연산자: ++, -- (전위, 후위)\n\nint num = 5;\nConsole.WriteLine(num++); // 5 (출력 후에 증가)\nConsole.WriteLine(num);   // 6\nConsole.WriteLine(++num); // 7 (미리 증가 후에 출력)\n\n문자열 결합 연산자: +\n\nstring hello = \"Hello\";\nstring world = \"World\";\nstring combined = hello + \" \" + world; // \"Hello World\"\n\n관계 연산자: ==, !=, &gt;, &lt;, &gt;=, &lt;=\n\nint a = 10, b = 20;\nConsole.WriteLine(a == b); // false\nConsole.WriteLine(a != b); // true\nConsole.WriteLine(a &gt; b);  // false\n\n논리 연산자: &&, ||, !\n\nbool c = true, d = false;\nConsole.WriteLine(c && d); // false\nConsole.WriteLine(c || d); // true\nConsole.WriteLine(!c);     // false\n\n조건 연산자 (삼항 연산자): ?:\n\nint score = 85;\nstring result = (score &gt;= 60) ? \"합격\" : \"불합격\";\n\n비트 연산자: &, |, ^, ~, &lt;&lt;, &gt;&gt;\n\nint e = 10;    // 1010 (2진수)\nint f = 12;    // 1100 (2진수)\nConsole.WriteLine(e & f); // 8 (1000)\nConsole.WriteLine(e | f); // 14(1110)\nConsole.WriteLine(e ^ f); // 6 (0110)\n\nint g = 1;\nConsole.WriteLine(g &lt;&lt; 2); // 4  (1을 왼쪽으로 2비트 이동)\nConsole.WriteLine(g &gt;&gt; 1); // 0  (1을 오른쪽으로 1비트 이동)\n\n할당 연산자: =, +=, -=, *=, /=, %=, &=, |=, ^=, &lt;&lt;=, &gt;&gt;=\n\nint h = 10;\nh += 5;  // h = 15\nh &lt;&lt;= 1; // h = 30 (이진수로 한 칸 왼쪽 이동)\n\nnull 조건부 연산자: ?. (null인 경우 null 반환),\nnull 병합 연산자: ?? (null인 경우 다른 값 반환)\n\nstring? nullString = null;\nint? length = nullString?.Length; // nullString이 null이면 전체 결과가 null\nstring? maybeNull = null;\nstring resultString = maybeNull ?? \"값이 null이었어요\"; \n// maybeNull이 null이면 뒤의 \"값이 null이었어요\" 대입",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#기타-형식-관련-내용",
    "href": "notes/03.html#기타-형식-관련-내용",
    "title": "Value, Ref, Types",
    "section": "기타 형식 관련 내용",
    "text": "기타 형식 관련 내용\n\n데이터 형식 바꾸기(type conversion):\n\n암시적 변환 (Implicit Conversion): 데이터 손실이 없는 경우 자동으로 수행되는 변환\n명시적 변환 (Explicit Conversion/Casting): 데이터 손실이 발생할 수 있는 경우 명시적으로 지정해야 하는 변환\n\n\nlong bigNum = 123456789;\nint smallerNum = (int)bigNum; // 명시적 캐스팅\n\n상수(const): 컴파일 시간에 값이 결정되는 변하지 않는 값\n\nconst double PI = 3.141592;\n\nnullable 형식(nullable types): 값 형식이 null 값을 가질 수 있도록 하는 형식. int?, bool? 등의 형태로 사용\n\nint? x = null;\nx = 10;\n\nvar 형식(var keyword): 컴파일러가 변수의 형식을 추론하도록 하는 키워드. 지역 변수 선언 시에만 사용 가능\n\nvar number = 10;      // number는 int로 추론\nvar text = \"Hello\";   // text는 string으로 추론\n\n공용 형식 시스템(common type system, cts): .NET 런타임 환경에서 모든 형식이 어떻게 표현되고 사용되는지를 정의하는 명세(int → System.Int32, string → System.String 등)\n\n\n예제\nusing System;\n\npublic class Person\n{\n    public string Name;\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        // 값 형식 예시\n        int valueA = 10;\n        int valueB = valueA;\n        valueB = 20;\n        Console.WriteLine($\"valueA = {valueA}, valueB = {valueB}\"); \n        // valueA = 10, valueB = 20 (복사본이기 때문)\n\n        // 참조 형식 예시\n        Person person1 = new Person();\n        person1.Name = \"Kim\";\n\n        Person person2 = person1; // 같은 참조를 복사\n        person2.Name = \"Lee\";\n\n        Console.WriteLine($\"person1.Name = {person1.Name}, person2.Name = {person2.Name}\");\n        // person1.Name = Lee, person2.Name = Lee (같은 객체 참조)\n    }\n}",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/03.html#패턴-매칭",
    "href": "notes/03.html#패턴-매칭",
    "title": "Value, Ref, Types",
    "section": "패턴 매칭",
    "text": "패턴 매칭\nC#의 패턴 매칭(Pattern Matching)은 데이터의 구조와 값에 따라 코드를 분기하거나 특정 데이터를 추출하는 강력한 기능입니다. 기존의 if문이나 switch문을 사용하는 것보다 더 간결하고 가독성이 좋은 코드를 작성할 수 있도록 도와줍니다. C# 7.0부터 도입되어 이후 버전에서 지속적으로 확장되고 있으며, 현재 C#의 중요한 기능 중 하나로 자리 잡았습니다.\n패턴 매칭은 특정 데이터가 어떤 패턴과 일치하는지 확인하고, 일치하는 패턴에 따라 다른 동작을 수행하는 과정입니다. C#에서는 다양한 형태의 패턴을 사용할 수 있으며, 이를 통해 복잡한 조건 분기를 쉽게 처리할 수 있습니다.\n\n주요 패턴 종류\n\n선언 패턴(Declaration Pattern): 특정 객체가 예상한 형식인지 검사하면서 형식 변환을 수행할 수 있습니다.\nif (obj is string text)\n{\n    return $\"문자열: {text}\";\n}\nreturn \"알 수 없는 타입\";\n\n\n형식 패턴(Type Pattern): 객체가 특정 형식과 일치하는지 검사하는 데 사용됩니다.\nreturn obj switch\n{\n    int =&gt; \"정수\",\n    double =&gt; \"실수\",\n    string =&gt; \"문자열\",\n    _ =&gt; \"알 수 없는 타입\"\n};\n\n\n상수 패턴(Constant Pattern): 특정 상수 값과 일치하는지 확인합니다.\nobject obj = 10;\n\nif (obj is 10)\n{\n    Console.WriteLine(\"obj is 10\");\n}\n\n\n속성 패턴(Property Pattern): 객체의 특정 속성 값과 일치하는지 확인합니다.\npublic class Person {\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nPerson person = new Person { Name = \"Alice\", Age = 30 };\n\nif (person is { Name: \"Alice\", Age: 30 })\n{\n    Console.WriteLine(\"person is Alice, 30 years old\");\n}\n\n\n관계형 패턴(Relational Pattern): 값의 관계를 확인합니다. (&gt;, &lt;, &gt;=, &lt;=)\nint age = 25;\nif (age is &gt; 18)\n{\n    Console.WriteLine(\"age is greater than 18\");\n}\n\n\n논리 패턴(Logical Pattern): 패턴들을 조합하여 복잡한 조건을 만듭니다. (and, or, not)\nint num = 15;\nif (num is &gt; 10 and &lt; 20) // and 패턴\n{\n    Console.WriteLine(\"num is between 10 and 20\");\n}\n\nif (num is &lt; 5 or &gt; 20) // or 패턴\n{\n      Console.WriteLine(\"num is less than 5 or greater than 20\");\n}\n\nif (num is not 10) // not 패턴\n{\n    Console.WriteLine(\"num is not 10\");\n}\n\n\n괄호 패턴(Parenthesized Pattern): 패턴을 그룹화하는 데 사용됩니다.\nreturn number is (&gt; 0 and &lt; 100);\n\n\n위치 패턴(Positional Pattern): 객체의 생성자 또는 Deconstruct 메서드를 통해 분해된 값과 일치하는지 확인합니다.\npublic class Point {\n    public int X { get; set; }\n    public int Y { get; set; }\n    public void Deconstruct(out int x, out int y)\n    {\n        x = X;\n        y = Y;\n    }\n}\nPoint point = new Point { X = 10, Y = 20 };\nif (point is (10, 20))\n{\n    Console.WriteLine(\"point is (10, 20)\");\n}\n\n\n변수 패턴(Var Pattern): 모든 값과 일치하며, 값을 새로운 변수에 할당합니다.\nobject obj = 20;\n\nif (obj is var value)\n{\n    Console.WriteLine($\"obj value: {value}\");\n}\n\n\n버리기 패턴(Discard Pattern): 값과 일치하지만, 값을 변수에 할당하지 않고 버립니다.\nobject obj = null;\n\nif(obj is not null)\n{ \n    // 변수에 할당하지 않고 단순히 null 이 아님을 검사\n    Console.WriteLine($\"obj is not null\");\n}\n\nif (obj is _)\n{\n    Console.WriteLine(\"obj is something, but I don't care\");\n}\n\n\n리스트 패턴(List Pattern): 리스트 혹은 배열의 구조를 확인합니다.\nint[] numbers = { 1, 2, 3, 4, 5 };\nif (numbers is [1, 2, 3, _, 5])\n{\n    onsole.WriteLine(\"List pattern matches with 1, 2, 3, *, 5\");\n}\n\n\n\n패턴 매칭의 활용\n\nis 연산자: 특정 패턴과 일치하는지 확인합니다.\n\nif (obj is string str)\n{\n    // ...\n}\n\nswitch 문: 패턴에 따라 분기 처리를 합니다.\n\nobject obj = 10;\nswitch (obj)\n{\n    case int i when i &gt; 5: // when절을 추가하여 더 복잡한 조건 설정가능\n        Console.WriteLine(\"obj is an int greater than 5\");\n        break;\n    case string str:\n        Console.WriteLine($\"obj is a string: {str}\");\n        break;\n    case null:\n        Console.WriteLine(\"obj is null\");\n        break;\n    default:\n        Console.WriteLine(\"obj does not match any cases\");\n        break;\n}\n\n\n패턴 매칭의 장점\n\n가독성 향상: 복잡한 조건 분기를 더 명확하고 간결하게 표현할 수 있습니다.\n코드 간결화: 불필요한 타입 변환 및 조건 검사를 줄일 수 있습니다.\n유지 보수성 향상: 코드를 더 이해하고 변경하기 쉽도록 만들어줍니다.\n안정성: 타입 안정성이 향상되어 런타임 오류를 줄일 수 있습니다.\n\nC#의 패턴 매칭은 코드를 더욱 간결하고 가독성 있게 만들 뿐만 아니라, 복잡한 조건 분기를 쉽게 처리할 수 있도록 해주는 강력한 기능입니다. 다양한 종류의 패턴을 익히고 적절하게 활용한다면, 코드의 품질을 높이고 개발 생산성을 향상시킬 수 있을 것입니다.",
    "crumbs": [
      "Value, Ref, Types"
    ]
  },
  {
    "objectID": "notes/01.html",
    "href": "notes/01.html",
    "title": "C#과 .NET",
    "section": "",
    "text": "C#은 Microsoft에서 1999년에 개발한 프로그래밍 언어입니다. 현대적이고 객체 지향적인 언어로, .NET 프레임워크에서 실행되도록 설계되었습니다. C#의 문법은 C++ 및 Java와 유사합니다. C#은 출시된 이후 여러 번의 개정을 거쳐 새로운 기능을 추가했습니다. 오늘날 C#은 Windows 데스크톱 애플리케이션, 웹 애플리케이션, 게임 및 모바일 앱 개발에 활용할 수 있습니다.\n\n\n\n파일 범위 네임스페이스(File-scoped namespace), 기존에는 네임스페이스를 감싸는 중괄호 {} 를 사용해야 했습니다. C# 10에서는 파일 최상단에 한 줄로 선언이 가능합니다. 코드 중첩이 줄어들어 가독성과 유지보수성이 향상됩니다.\n\n// after\nnamespace MyApp\n{\n    class Program\n    {\n        static void Main() { }\n    }\n}\n\n// before\nnamespace MyApp;\n\nclass Program\n{\n    static void Main() { }\n}\n\n전역 using 지시문(Global using directives), using 지시문을 전역으로 선언하여, 모든 파일에서 공통으로 사용할 수 있도록 해줍니다. 프로젝트 전역에서 공통 사용되는 네임스페이스를 한 곳에 모아 정리할 수 있어, 코드 중복을 줄입니다.\n\n// GlobalUsings.cs (프로젝트 내 한 곳에만 작성)\nglobal using System;\nglobal using System.Collections.Generic;\n\n// 다른 파일 어디서든 System, System.Collections.Generic를 별도의 using 없이 사용 가능\nnamespace MyApp;\n\npublic class Demo\n{\n    public List&lt;string&gt; Names { get; set; } = new();\n}\n\nRecord structs, C# 9에서 소개된 record는 기본적으로 참조 타입이었으나, C# 10부터는 값 타입인 구조체 형태도 지원합니다. 구조체의 값 복사 특성과 레코드의 불변성 및 편의 기능을 동시에 활용할 수 있습니다.\n\npublic record struct Point(int X, int Y);\nvar p1 = new Point(3, 4);\nvar p2 = p1 with { Y = 10 }; \n// 구조체지만 record로 선언했기 때문에 with 식 사용 가능\nConsole.WriteLine(p2); // Point { X = 3, Y = 10 }\n\n람다 식 개선(Lambda improvements), 람다 식에서 반환 형식을 컴파일러가 추론할 수 있으며, 람다 식에 속성(Attribute)을 붙일 수 있습니다. 매개변수가 없는 람다 식에서 _(디스카드)를 사용해도 됩니다.\n\nFunc&lt;int, int&gt; square = [MyAttribute] x =&gt; x * x; \n// 반환형 추론, Attribute 적용 가능\nvar print = () =&gt; Console.WriteLine(\"Hello\");\nprint();\n\n상수 문자열 보간(Constant interpolated strings), 상수(const) 필드에서도 문자열 보간이 가능해졌습니다.\n\nconst string Greeting = \"Hello\";\nconst string Message = $\"{Greeting}, World!\"; \n// C# 9까지는 불가, C# 10에서는 가능\n\n\n\n\n원시 문자열 리터럴(Raw string literals), 문자열을 \"\"\"로 둘러싸, 특수문자나 줄바꿈을 이스케이프 없이 그대로 표현할 수 있습니다. JSON, XML, Markdown 등의 멀티라인 문자열을 가독성 좋게 표현할 수 있습니다.\n\nstring raw = \"\"\"\n    이것은 \"원시\" 문자열입니다.\n    \\n, \\t 등을 이스케이프 처리하지 않아도 됩니다.\n\"\"\";\nConsole.WriteLine(raw);\n\nUTF-8 문자열 리터럴(UTF-8 string literals), 문자열 리터럴 뒤에 u8 접미사를 붙여 UTF-8 인코딩된 바이트 배열을 직접 생성할 수 있습니다. 별도의 인코딩 과정 없이 UTF-8 바이트 배열을 얻을 수 있어 성능상 이점이 있습니다.\n\nReadOnlySpan&lt;byte&gt; utf8Bytes = \"안녕하세요\"u8;\nConsole.WriteLine(utf8Bytes.Length);  // UTF-8로 인코딩된 길이\n\nrequired, 객체나 레코드가 생성될 때 반드시 초기화해야 하는 필드를 지정할 수 있습니다. 중요한 필드의 누락을 컴파일 시간에 미리 방지할 수 있습니다.\n\npublic class Person\n{\n    public required string Name { get; init; }\n    public int Age { get; init; }\n}\nvar p = new Person { Name = \"Alice\", Age = 30 }; \n// Name은 반드시 설정, Age는 선택\n\n정적 추상 멤버(Static abstract members in interfaces), 인터페이스에 정적 추상 멤버를 정의할 수 있어, 제네릭 수학 연산 등 다양한 패턴을 지원합니다. +, - 연산자나 수학 관련 함수를 제네릭에서 간단히 이용할 수 있어, 수치 라이브러리 구현이 용이해집니다.\n\npublic interface IAddition&lt;TSelf&gt; where TSelf : IAddition&lt;TSelf&gt;\n{\n    static abstract TSelf operator +(TSelf left, TSelf right);\n}\n\npublic struct MyInt : IAddition&lt;MyInt&gt;\n{\n    public int Value { get; set; }\n    public MyInt(int value) =&gt; Value = value;\n\n    public static MyInt operator +(MyInt left, MyInt right)\n        =&gt; new MyInt(left.Value + right.Value);\n}\n\n리스트 패턴(List patterns), 배열이나 리스트를 패턴 매칭으로 검사할 수 있습니다. 배열의 특정 형태를 깔끔하게 검사할 수 있습니다.\n\nint[] numbers = { 1, 2, 3 };\n// 완벽 일치\nif (numbers is [1, 2, 3]) Console.WriteLine(\"numbers는 1,2,3으로 구성\");\nif (numbers is [1, ..]) Console.WriteLine(\"첫 번째 요소가 1\");\n\nfile 접근 한정자(File-scoped types), file 한정자를 사용해 해당 파일 내에서만 유효한 클래스(또는 구조체, 열거형 등)를 선언할 수 있습니다. 특정 파일에서만 사용하는 헬퍼 타입 등을 은닉하여, 네임스페이스 오염을 줄일 수 있습니다.\n\nfile class MyFileScopedClass\n{\n    // 이 파일 바깥에서는 접근 불가\n}\n\n\n\n\n클래스/구조체용 기본 생성자 (Primary constructors for non-record types), 레코드가 아닌 일반 클래스나 구조체에서도 생성자 매개변수를 클래스 선언부에 직접 선언할 수 있습니다. 레코드에서 사용하던 간결한 생성자 문법을 일반 클래스/구조체에도 적용 가능해집니다.\n\nclass Person(string name, int age) \n{\n    public string Name { get; } = name;\n    public int Age { get; } = age;\n}\nvar p = new Person(\"Alice\", 30);\nConsole.WriteLine(p.Name); // \"Alice\"\n\nusing 별칭 지시문(Using alias directive) 확장, 임의의 타입이나 멤버에 대해 using 별칭을 지정할 수 있도록 확장될 예정입니다. 긴 네임스페이스나 자주 쓰는 멤버를 짧게 별칭화하여 가독성을 높입니다.\n\nusing MyInt = System.Int32;\nusing static System.Math;\nConsole.WriteLine(Sqrt(25)); // using static System.Math 덕분에 바로 Sqrt 사용\n\n람다 파라미터 기본값(Default values for lambda parameters), 람다 식의 매개변수에 기본값을 지정할 수 있게 됩니다. 메서드와 동일한 방식으로 매개변수의 기본값을 설정할 수 있어, 코드가 더 간결해집니다.\n\nFunc&lt;int, int, int&gt; add = (x = 0, y = 0) =&gt; x + y;\nConsole.WriteLine(add());      // 0\nConsole.WriteLine(add(5));     // 5\nConsole.WriteLine(add(5, 10)); // 15",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#c",
    "href": "notes/01.html#c",
    "title": "C#과 .NET",
    "section": "",
    "text": "C#은 Microsoft에서 1999년에 개발한 프로그래밍 언어입니다. 현대적이고 객체 지향적인 언어로, .NET 프레임워크에서 실행되도록 설계되었습니다. C#의 문법은 C++ 및 Java와 유사합니다. C#은 출시된 이후 여러 번의 개정을 거쳐 새로운 기능을 추가했습니다. 오늘날 C#은 Windows 데스크톱 애플리케이션, 웹 애플리케이션, 게임 및 모바일 앱 개발에 활용할 수 있습니다.\n\n\n\n파일 범위 네임스페이스(File-scoped namespace), 기존에는 네임스페이스를 감싸는 중괄호 {} 를 사용해야 했습니다. C# 10에서는 파일 최상단에 한 줄로 선언이 가능합니다. 코드 중첩이 줄어들어 가독성과 유지보수성이 향상됩니다.\n\n// after\nnamespace MyApp\n{\n    class Program\n    {\n        static void Main() { }\n    }\n}\n\n// before\nnamespace MyApp;\n\nclass Program\n{\n    static void Main() { }\n}\n\n전역 using 지시문(Global using directives), using 지시문을 전역으로 선언하여, 모든 파일에서 공통으로 사용할 수 있도록 해줍니다. 프로젝트 전역에서 공통 사용되는 네임스페이스를 한 곳에 모아 정리할 수 있어, 코드 중복을 줄입니다.\n\n// GlobalUsings.cs (프로젝트 내 한 곳에만 작성)\nglobal using System;\nglobal using System.Collections.Generic;\n\n// 다른 파일 어디서든 System, System.Collections.Generic를 별도의 using 없이 사용 가능\nnamespace MyApp;\n\npublic class Demo\n{\n    public List&lt;string&gt; Names { get; set; } = new();\n}\n\nRecord structs, C# 9에서 소개된 record는 기본적으로 참조 타입이었으나, C# 10부터는 값 타입인 구조체 형태도 지원합니다. 구조체의 값 복사 특성과 레코드의 불변성 및 편의 기능을 동시에 활용할 수 있습니다.\n\npublic record struct Point(int X, int Y);\nvar p1 = new Point(3, 4);\nvar p2 = p1 with { Y = 10 }; \n// 구조체지만 record로 선언했기 때문에 with 식 사용 가능\nConsole.WriteLine(p2); // Point { X = 3, Y = 10 }\n\n람다 식 개선(Lambda improvements), 람다 식에서 반환 형식을 컴파일러가 추론할 수 있으며, 람다 식에 속성(Attribute)을 붙일 수 있습니다. 매개변수가 없는 람다 식에서 _(디스카드)를 사용해도 됩니다.\n\nFunc&lt;int, int&gt; square = [MyAttribute] x =&gt; x * x; \n// 반환형 추론, Attribute 적용 가능\nvar print = () =&gt; Console.WriteLine(\"Hello\");\nprint();\n\n상수 문자열 보간(Constant interpolated strings), 상수(const) 필드에서도 문자열 보간이 가능해졌습니다.\n\nconst string Greeting = \"Hello\";\nconst string Message = $\"{Greeting}, World!\"; \n// C# 9까지는 불가, C# 10에서는 가능\n\n\n\n\n원시 문자열 리터럴(Raw string literals), 문자열을 \"\"\"로 둘러싸, 특수문자나 줄바꿈을 이스케이프 없이 그대로 표현할 수 있습니다. JSON, XML, Markdown 등의 멀티라인 문자열을 가독성 좋게 표현할 수 있습니다.\n\nstring raw = \"\"\"\n    이것은 \"원시\" 문자열입니다.\n    \\n, \\t 등을 이스케이프 처리하지 않아도 됩니다.\n\"\"\";\nConsole.WriteLine(raw);\n\nUTF-8 문자열 리터럴(UTF-8 string literals), 문자열 리터럴 뒤에 u8 접미사를 붙여 UTF-8 인코딩된 바이트 배열을 직접 생성할 수 있습니다. 별도의 인코딩 과정 없이 UTF-8 바이트 배열을 얻을 수 있어 성능상 이점이 있습니다.\n\nReadOnlySpan&lt;byte&gt; utf8Bytes = \"안녕하세요\"u8;\nConsole.WriteLine(utf8Bytes.Length);  // UTF-8로 인코딩된 길이\n\nrequired, 객체나 레코드가 생성될 때 반드시 초기화해야 하는 필드를 지정할 수 있습니다. 중요한 필드의 누락을 컴파일 시간에 미리 방지할 수 있습니다.\n\npublic class Person\n{\n    public required string Name { get; init; }\n    public int Age { get; init; }\n}\nvar p = new Person { Name = \"Alice\", Age = 30 }; \n// Name은 반드시 설정, Age는 선택\n\n정적 추상 멤버(Static abstract members in interfaces), 인터페이스에 정적 추상 멤버를 정의할 수 있어, 제네릭 수학 연산 등 다양한 패턴을 지원합니다. +, - 연산자나 수학 관련 함수를 제네릭에서 간단히 이용할 수 있어, 수치 라이브러리 구현이 용이해집니다.\n\npublic interface IAddition&lt;TSelf&gt; where TSelf : IAddition&lt;TSelf&gt;\n{\n    static abstract TSelf operator +(TSelf left, TSelf right);\n}\n\npublic struct MyInt : IAddition&lt;MyInt&gt;\n{\n    public int Value { get; set; }\n    public MyInt(int value) =&gt; Value = value;\n\n    public static MyInt operator +(MyInt left, MyInt right)\n        =&gt; new MyInt(left.Value + right.Value);\n}\n\n리스트 패턴(List patterns), 배열이나 리스트를 패턴 매칭으로 검사할 수 있습니다. 배열의 특정 형태를 깔끔하게 검사할 수 있습니다.\n\nint[] numbers = { 1, 2, 3 };\n// 완벽 일치\nif (numbers is [1, 2, 3]) Console.WriteLine(\"numbers는 1,2,3으로 구성\");\nif (numbers is [1, ..]) Console.WriteLine(\"첫 번째 요소가 1\");\n\nfile 접근 한정자(File-scoped types), file 한정자를 사용해 해당 파일 내에서만 유효한 클래스(또는 구조체, 열거형 등)를 선언할 수 있습니다. 특정 파일에서만 사용하는 헬퍼 타입 등을 은닉하여, 네임스페이스 오염을 줄일 수 있습니다.\n\nfile class MyFileScopedClass\n{\n    // 이 파일 바깥에서는 접근 불가\n}\n\n\n\n\n클래스/구조체용 기본 생성자 (Primary constructors for non-record types), 레코드가 아닌 일반 클래스나 구조체에서도 생성자 매개변수를 클래스 선언부에 직접 선언할 수 있습니다. 레코드에서 사용하던 간결한 생성자 문법을 일반 클래스/구조체에도 적용 가능해집니다.\n\nclass Person(string name, int age) \n{\n    public string Name { get; } = name;\n    public int Age { get; } = age;\n}\nvar p = new Person(\"Alice\", 30);\nConsole.WriteLine(p.Name); // \"Alice\"\n\nusing 별칭 지시문(Using alias directive) 확장, 임의의 타입이나 멤버에 대해 using 별칭을 지정할 수 있도록 확장될 예정입니다. 긴 네임스페이스나 자주 쓰는 멤버를 짧게 별칭화하여 가독성을 높입니다.\n\nusing MyInt = System.Int32;\nusing static System.Math;\nConsole.WriteLine(Sqrt(25)); // using static System.Math 덕분에 바로 Sqrt 사용\n\n람다 파라미터 기본값(Default values for lambda parameters), 람다 식의 매개변수에 기본값을 지정할 수 있게 됩니다. 메서드와 동일한 방식으로 매개변수의 기본값을 설정할 수 있어, 코드가 더 간결해집니다.\n\nFunc&lt;int, int, int&gt; add = (x = 0, y = 0) =&gt; x + y;\nConsole.WriteLine(add());      // 0\nConsole.WriteLine(add(5));     // 5\nConsole.WriteLine(add(5, 10)); // 15",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#net",
    "href": "notes/01.html#net",
    "title": "C#과 .NET",
    "section": ".NET",
    "text": ".NET\n.NET은 Microsoft에서 개발한 소프트웨어 개발 플랫폼입니다. 2002년 처음 출시된 이후 윈도우 애플리케이션 개발을 위한 강력한 도구로 자리매김했으며, 현재는 웹, 모바일, 게임, IoT, AI 등 다양한 분야에서 활용되고 있습니다. .NET은 개발자가 다양한 프로그래밍 언어를 사용하여 애플리케이션을 구축할 수 있도록 지원하며, 풍부한 라이브러리와 도구를 제공하여 개발 생산성을 향상시킵니다. 은 아래와 같습니다.\n\n.NET의 주요 특징\n\n다양한 언어 지원, C#, F#, Visual Basic 등 다양한 프로그래밍 언어를 지원\n크로스 플랫폼, .NET Core 이후 버전부터는 윈도우, macOS, Linux 등 다양한 운영체제에서 실행 가능\n풍부한 라이브러리: 다양한 작업을 위한 풍부한 클래스 라이브러리를 제공\n뛰어난 성능: Just-In-Time (JIT) 컴파일을 통해 높은 성능을 제공\n\n\n\n.NET의 장점\n\n생산성 향상, 풍부한 라이브러리와 도구를 통해 개발 시간을 단축하고 생산성을 향상시킬 수 있음\n유지 보수 용이성, 객체 지향 프로그래밍 및 모듈식 설계를 통해 코드를 쉽게 유지 보수할 수 있음\n안정성, 강력한 형식 검사 및 예외 처리 메커니즘을 통해 안정적인 애플리케이션을 개발할 수 있음\n확장성, .NET 애플리케이션은 높은 확장성을 제공하여 대규모 시스템 구축에 적합\n\n\n\n.NET의 변화: 과거와 현재\n.NET은 처음 출시된 이후 지속적인 발전을 거듭해왔습니다. 초기에는 윈도우 데스크톱 애플리케이션 개발에 중점을 두었지만, 현재는 웹, 모바일, 클라우드, 게임 등 다양한 분야에서 활용될 수 있도록 진화했습니다. 이러한 변화는 .NET Framework에서 .NET Core로의 전환, 그리고 .NET 5, 6, 7, 8, 9로 이어지는 통합 및 발전 과정을 통해 이루어졌습니다.\n\n.NET Framework 시대 (2002년 ~ 2016년)\n.NET Framework는 2002년 처음 출시되었습니다. 윈도우 운영체제에서 애플리케이션을 개발하고 실행하기 위한 프레임워크로, C#, Visual Basic, F# 등 다양한 언어를 지원했습니다. .NET Framework는 윈도우 데스크톱 애플리케이션, 웹 애플리케이션, 웹 서비스 등 다양한 애플리케이션 개발에 널리 사용되었습니다. 당시에는 윈도우 운영체제에 종속적이었습니다. ASP.NET 웹 프레임워크를 통해 웹 애플리케이션 개발을 지원하였고, Windows Forms 및 WPF를 통해 데스크톱 애플리케이션 개발을 지원하였습니다. .NET Framework는 윈도우 애플리케이션 개발에 큰 영향을 미쳤지만, 윈도우 운영체제에 종속적이라는 한계를 가지고 있었습니다. 이러한 한계를 극복하고 크로스 플랫폼 지원을 위해 .NET Core가 등장하게 됩니다.\n\n\n.NET Core 시대 (2016년 ~ 2020년)\n.NET Framework의 한계를 극복하고 크로스 플랫폼 지원, 오픈 소스 생태계 확장, 성능 향상을 목표로 2016년 .NET Core가 출시되었습니다. .NET Core는 모듈식 디자인을 채택하여 개발자가 필요한 구성 요소만 선택적으로 사용할 수 있도록 하였고, 이는 애플리케이션의 크기를 줄이고 배포를 용이하게 했습니다. 또한, 명령줄 인터페이스(CLI)를 통해 개발자가 다양한 플랫폼에서 애플리케이션을 빌드하고 실행할 수 있도록 지원했습니다. 윈도우, macOS, Linux 등 다양한 운영체제에서 실행 가능하도록 개선하였고, .NET Core는 오픈 소스 프로젝트로, 개발자 커뮤니티의 참여를 통해 빠르게 발전했습니다. 필요한 구성 요소만 선택적으로 사용할 수 있어 애플리케이션 크기를 줄이고 배포를 용이하게 합니다. .NET Framework 대비 성능이 크게 향상되었습니다. CLI를 통해 다양한 플랫폼에서 애플리케이션을 빌드하고 실행할 수 있습니다. .NET Core는 크로스 플랫폼 지원 및 오픈 소스 생태계 확장을 통해 .NET 플랫폼의 새로운 가능성을 열었습니다. 이후 .NET 5를 통해 .NET Framework와 .NET Core는 하나의 통합된 플랫폼으로 발전하게 됩니다.\n\n\n통합과 발전 (2020년 ~ 현재)\n2020년 11월, Microsoft는 .NET 5를 출시하며 .NET Framework와 .NET Core를 하나의 통합된 플랫폼으로 발전시켰습니다. .NET 5는 단일 코드 베이스로 윈도우, macOS, Linux, iOS, Android 등 다양한 플랫폼에서 실행 가능한 애플리케이션을 개발할 수 있도록 지원합니다. 또한, 성능 향상, 새로운 언어 기능 추가, 클라우드 네이티브 지원 강화 등 다양한 개선 사항을 포함했습니다. .NET 5 이후, Microsoft는 매년 새로운 버전의 .NET을 출시하며 플랫폼을 지속적으로 발전시키고 있습니다. .NET 6는 .NET MAUI를 통해 크로스 플랫폼 모바일 및 데스크톱 애플리케이션 개발을 지원하고, C# 10의 새로운 기능을 도입했습니다. .NET 7은 성능 향상과 클라우드 네이티브 지원 강화에 중점을 두었으며, .NET 8은 Blazor United를 통해 웹 UI 개발을 개선하고, .NET MAUI를 통해 윈도우 데스크톱 애플리케이션 개발을 지원합니다. .NET 9는 C# 12의 새로운 기능을 도입하고, 플랫폼 전반의 성능과 안정성을 향상시켰습니다.  \n\n\n\n\n\n\n\n\n\n\n버전\n출시일\n지원 유형 (대략)\n주요 특징\n지원 상태\n\n\n\n\n.NET 8\n2023년 11월 예정 (계획)\nLTS\n- Native AOT 개선  - 컨테이너 지원 확대  - 지속적인 성능 및 언어 기능 개선\n미출시 (프리뷰 진행 중)\n\n\n.NET 7\n2022년 11월 8일\n단기 지원(STS, 약 18개월)\n- Native AOT 기본 지원  - 컨테이너 성능 최적화  - C# 11 등 최신 언어 기능  - 전반적 성능 개선\n지원 중\n\n\n.NET 6\n2021년 11월 8일\n장기 지원(LTS, 3년)\n- C# 10, F# 6 지원  - Minimal APIs  - .NET MAUI  - 핫 리로드, 성능 개선 등\n지원 중\n\n\n.NET 5\n2020년 11월 10일\n단기 지원(STS, 약 18개월)\n- 단일 파일 배포  - 성능 및 컨테이너 개선  - .NET Core와 .NET Framework의 통합 시도\n지원 종료 (2022년 5월 10일)\n\n\n.NET Core 3.1\n2019년 12월 3일\n장기 지원(LTS, 3년)\n- Windows 데스크톱 (WinForms, WPF) 공식 지원  - 전반적 성능 및 기능 개선\n지원 종료 (2022년 12월 13일)\n\n\n.NET Core 3.0\n2019년 9월 23일\n단기 지원(STS, 약 18개월)\n- C# 8 지원  - Blazor 서버  - Worker Service 템플릿  - 성능 개선\n지원 종료 (2020년 3월 3일)\n\n\n.NET Core 2.2\n2018년 12월 4일\n단기 지원(STS, 약 18개월)\n- ASP.NET Core 강화  - 추가 성능 최적화\n지원 종료 (2019년 12월 23일)\n\n\n.NET Core 2.1\n2018년 5월 30일\n장기 지원(LTS, 3년)\n- Razor 클래스 라이브러리  - SignalR, gRPC 등  - Entity Framework Core 개선\n지원 종료 (2021년 8월 21일)\n\n\n.NET Core 2.0\n2017년 8월 14일\n단기 지원(STS, 약 18개월)\n- 성능 개선 및 self-contained 배포  - 새로운 csproj 구조\n지원 종료 (2018년 10월 1일)\n\n\n.NET Core 1.1\n2016년 11월 16일\n단기 지원(STS, 약 18개월)\n- 신규 API 추가  - 툴링 및 안정성 개선\n지원 종료 (2019년 6월 27일)\n\n\n.NET Core 1.0\n2016년 6월 27일\n장기 지원(LTS, 3년)\n- 초기 크로스 플랫폼 지원  - CLI 기반 개발 환경 도입\n지원 종료 (2019년 6월 27일)\n\n\n\n\n\n\nCLR\nCLR(Common Language Runtime)은 .NET에서 프로그램이 실행될 때 동작을 관리해 주는 엔진(또는 환경)입니다. 마치 자동차 엔진이 자동차의 작동을 책임지듯, .NET 프로그램이 안전하고 일관된 방식으로 실행될 수 있도록 다양한 기능을 제공합니다. C# 같은 고수준 언어는 사람에게 읽기 쉽지만, 컴퓨터가 직접 이해하기엔 적합하지 않습니다. 그래서 중간 단계인 IL(Intermediate Language) 코드를 거친 뒤, CLR이 이를 실제 기계어(컴퓨터가 바로 실행할 수 있는 언어)로 바꿔주어야 프로그램이 동작합니다. 이렇게 하면 여러 운영 체제나 하드웨어에서도 공통된 방식으로 실행될 수 있습니다.\n안전성과 편의성: 메모리 관리, 예외 처리와 같은 자잘하지만 중요한 부분들을 자동으로 처리해 줍니다. 덕분에 프로그래머는 주로 프로그램의 로직에만 집중할 수 있습니다.\n\n\nCLR의 주요 기능\n\n가비지 수집(Garbage Collection), 가비지 수집(Garbage Collection, GC) 은 프로그램이 사용했던 메모리 중 더 이상 사용하지 않는 부분을 CLR이 알아서 정리해 주는 기능입니다.수동으로 메모리를 관리하려면 ’어디서 할당하고 어디서 해제해야 할까?’를 계속 생각해야 하는데, GC 덕분에 그 부담을 줄일 수 있습니다. 메모리를 잘못 정리하면 프로그램이 오작동하거나 멈출 수 있는데, GC가 자동으로 해 주므로 안전성이 높아집니다.\nJIT 컴파일(Just-In-Time Compilation), C# 코드 → IL 코드 → (실행 시점에) → 기계어 코드이 순서로 변환되는데, IL 코드를 최종적으로 기계어로 바꿔 주는 역할을 CLR이 맡습니다. 이 과정을 JIT(Just-In-Time) 컴파일 이라고 합니다. “Just-In-Time”이라는 이름대로, 미리 전부 변환해 두는 것이 아니라 실행에 필요한 순간에 해당 코드를 컴파일합니다. 이렇게 하면 시작 시점의 부담을 줄이고, 실행되는 부분만 빠르게 기계어로 변환할 수 있어 효율적입니다.\n어셈블리(Assembly) 로딩 및 관리, .NET에서 코드를 묶어 배포하는 단위를 어셈블리(Assembly) 라고 부릅니다. (보통 .dll 또는 .exe 확장자를 가집니다.) CLR은 필요한 어셈블리를 찾아서 프로그램이 잘 쓸 수 있도록 관리하고, 실행 도중에 보안이나 버전 충돌을 점검하기도 합니다.\n타입 시스템 관리, .NET에는 다양한 자료형(int, string, double 등)이 있는데, 이들을 한데 묶어 통합적으로 정의한 것을 Common Type System(CTS) 라고 합니다. CLR은 CTS를 기반으로 모든 언어(C#, VB.NET 등)에서 동일한 자료형을 다룰 수 있게 해 줍니다. 예를 들어, C#에서 int 타입은 VB.NET의 Integer 타입과 사실상 동일한 구조를 갖습니다. CLR이 내부적으로 같은 구조를 공유하도록 관리하기 때문이죠.\n예외 처리 및 디버깅 지원, 프로그램이 실행될 때 오류(예외)가 발생하면, CLR이 예외를 인식하고 이를 프로그램에게 알려줄 수 있도록 구조를 갖추고 있습니다. 또한 CLR은 디버깅(문제 해결을 위해 프로그램 내부를 조사하는 과정)과 프로파일링(프로그램의 성능을 측정하고 분석하는 기능)을 지원해 줍니다.\n\n\nCLR의 이점\n\n안전한 메모리 관리, GC 덕분에 메모리 누수를 일으키기 쉬운 실수를 줄일 수 있습니다.\n높은 호환성, IL 코드를 기반으로 JIT 컴파일되므로, 여러 플랫폼에서 동일한 프로그램을 실행할 수 있습니다(플랫폼 전용 .NET 런타임을 사용).\n개발 생산성, 예외 처리, 디버깅, 형식 안전성, 풍부한 라이브러리 지원 덕분에 개발 속도가 빨라지고 오류도 줄일 수 있습니다.\n다양한 언어 지원, CLR 덕분에 C#, VB.NET, F#, Python(.NET용 IronPython) 등 다양한 언어가 서로 어셈블리를 공유하면서 .NET 위에서 돌아갈 수 있습니다.",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#c과.net의-관계",
    "href": "notes/01.html#c과.net의-관계",
    "title": "C#과 .NET",
    "section": "C#과.NET의 관계",
    "text": "C#과.NET의 관계\nC#은 프로그래밍 언어이고, .NET은 애플리케이션을 개발하고 실행하기 위한 플랫폼입니다. C#은 .NET 플랫폼에서 실행되는 여러 언어 중 하나이며, .NET은 C# 코드를 실행하는 데 필요한 환경을 제공합니다. C# 언어 자체는 변수, 데이터 유형, 연산자, 제어문, 함수 등 프로그래밍의 기본적인 구성 요소를 제공합니다 . 또한 객체 지향 프로그래밍, 제네릭, LINQ 등과 같은 고급 기능도 제공합니다. 반면 .NET은 CLR(Common Language Runtime), 기본 클래스 라이브러리(BCL), 그리고 다양한 API와 프레임워크를 제공합니다 . CLR은 C# 코드를 실행하는 런타임 환경이며, BCL은 문자열 처리, 파일 입출력, 네트워킹 등과 같은 일반적인 작업을 위한 클래스 라이브러리를 제공합니다. .NET은 또한 ASP.NET, Windows Forms, WPF, Xamarin 등과 같은 다양한 애플리케이션 프레임워크를 제공합니다. C#은 .NET 플랫폼에서 애플리케이션을 개발하기 위한 도구이며, .NET은 C# 코드를 실행하고 다양한 기능을 제공하는 환경입니다. 둘은 서로 협력하여 강력하고 다양한 애플리케이션을 개발할 수 있도록 지원합니다.",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practice C#",
    "section": "",
    "text": "C#과 .NET\n\n\nVisual Studio와 Solution\n\n\n\n\n\n\nData, Value 그리고 Ref\n\n\nStruct and Class\n\n\n인터페이스와 추상 클래스\n\n\n프로퍼티\n\n\n메소드\n\n\n배열과 컬렉션\n\n\n예외 처리하기\n\n\n파일 다루기\n\n\n\n\n\n\n\n대리자와 이벤트\n\n\n일반화 프로그래밍\n\n\n람다식와 LINQ\n\n\n리플렉션과 애트리뷰트\n\n\ndynamic 형식\n\n\n스레드와 태스크\n\n\n가비지 컬렉션\n\n\n\n\n\n\nMAUI"
  },
  {
    "objectID": "index.html#tools",
    "href": "index.html#tools",
    "title": "Practice C#",
    "section": "",
    "text": "C#과 .NET\n\n\nVisual Studio와 Solution\n\n\n\n\n\n\nData, Value 그리고 Ref\n\n\nStruct and Class\n\n\n인터페이스와 추상 클래스\n\n\n프로퍼티\n\n\n메소드\n\n\n배열과 컬렉션\n\n\n예외 처리하기\n\n\n파일 다루기\n\n\n\n\n\n\n\n대리자와 이벤트\n\n\n일반화 프로그래밍\n\n\n람다식와 LINQ\n\n\n리플렉션과 애트리뷰트\n\n\ndynamic 형식\n\n\n스레드와 태스크\n\n\n가비지 컬렉션\n\n\n\n\n\n\nMAUI"
  },
  {
    "objectID": "notes/02.html",
    "href": "notes/02.html",
    "title": "Visual Studio와 Solution",
    "section": "",
    "text": "Visual Studio는 1997년 Microsoft에서 처음 출시되었습니다. 당시에는 여러 개발 도구를 하나의 통합된 환경으로 제공하는 것을 목표로 하였습니다. 이전에는 Visual Basic, Visual C++, Visual FoxPro 등 개별적인 도구들을 사용해야 했지만, Visual Studio의 등장으로 이러한 도구들이 하나의 IDE(Integrated Development Environment, 통합 개발 환경) 안에서 통합되었습니다. 이를 통해 개발자들은 더욱 효율적으로 다양한 프로그래밍 언어를 사용하여 애플리케이션을 개발할 수 있게 되었습니다. 초기 버전의 Visual Studio는 주로 Windows 데스크톱 애플리케이션 개발에 초점을 맞추었습니다.\n2000년대에 들어서면서 웹 애플리케이션의 중요성이 커짐에 따라 Visual Studio는 ASP.NET과 같은 웹 개발 기술을 적극적으로 지원하기 시작했습니다. 또한, 엔터프라이즈급 애플리케이션 개발을 위한 기능들이 추가되면서 대규모 프로젝트 개발에도 적합한 도구로 자리매김하게 되었습니다. .NET Framework의 발전과 함께 Visual Studio는 더욱 강력한 기능을 제공하게 되었으며, 다양한 프로그래밍 언어(C#, VB.NET 등)를 지원하며 개발 생산성을 향상시키는 데 기여했습니다.\n2010년대 이후 모바일 및 클라우드 컴퓨팅이 급성장하면서 Visual Studio는 크로스 플랫폼 개발 및 클라우드 개발을 위한 지원을 강화했습니다. Xamarin을 통한 iOS, Android, Windows 등 다양한 플랫폼 대상의 모바일 앱 개발을 지원하고, Azure와의 통합을 통해 클라우드 기반 애플리케이션 개발을 용이하게 만들었습니다. 또한, 오픈 소스 생태계와의 협력을 강화하여 Git과 같은 버전 관리 시스템과의 통합을 개선하고 다양한 확장 기능을 제공하는 Visual Studio Marketplace를 통해 개발자들이 더욱 편리하게 개발할 수 있도록 지원하고 있습니다.\nVisual Studio는 출시 이후 지속적인 발전을 거듭하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 다양한 프로그래밍 언어와 플랫폼을 지원하는 통합 개발 환경으로서 개발자들이 효율적으로 고품질의 소프트웨어를 개발할 수 있도록 지원하는 핵심적인 역할을 수행하고 있습니다. 또한, 강력한 디버깅 도구, 코드 분석 기능, 테스트 도구 등을 통해 개발 과정 전반의 생산성을 향상시키는 데 기여하고 있습니다. 현재 Visual Studio는 Windows뿐만 아니라 macOS에서도 사용할 수 있는 Visual Studio for Mac, 그리고 더욱 가볍고 빠른 코드 편집기인 Visual Studio Code 등 다양한 형태로 제공되어 개발자들이 자신의 환경에 맞춰 선택하여 사용할 수 있도록 폭넓은 선택지를 제공하고 있습니다.\n\n\nVisual Studio를 처음 실행하면 사용자 설정에 맞게 다양하게 사용자 조정할 수 있는 작업 공간을 확인할 수 있습니다. 인터페이스의 주요 구성 요소는 다음과 같습니다.\n\n메뉴 바(menu bar): 상단에 위치한 메뉴 바는 파일, 편집, 보기 등과 같은 메뉴로 구성된 다양한 명령과 옵션에 대한 액세스를 제공합니다.\n도구 모음(toolbar): 메뉴 바 아래에는 자주 사용하는 도구와 작업에 대한 빠른 액세스를 제공하는 도구 모음이 있습니다. 프로젝트 빌드, 디버깅 및 실행과 같은 작업에 대한 버튼을 포함하는 경우가 많습니다.\n솔루션 탐색기(solution explorer): 화면 오른쪽에는 솔루션 탐색기가 있으며, 프로젝트 및 해당 파일을 관리하는 데 중요한 도구입니다. 솔루션과 해당 구성 요소의 계층적 보기를 표시합니다.\n코드 편집기(code editor): IDE의 중앙 영역은 코드 편집기가 차지합니다. 여기에서 소스 코드 파일을 작성, 편집 및 검토합니다. Visual Studio는 구문 강조, 코드 완성 및 오류 검사를 포함한 강력한 코드 편집 기능을 제공합니다.\n도구 창(tool windows): 이러한 창은 IDE 인터페이스에 도킹 또는 해제할 수 있는 추가 창입니다. 예를 들어 빌드 및 디버그 메시지를 표시하는 출력 창, 선택한 항목의 속성을 구성하는 속성 창, 코드 오류를 관리하는 오류 목록 창 등이 있습니다.\n솔루션 및 프로젝트 탭(solution and project tabs): 코드 편집기 위의 탭은 열려 있는 솔루션과 프로젝트를 나타냅니다. 해당 탭을 클릭하여 다른 솔루션 또는 프로젝트 간에 전환할 수 있습니다.\n상태 표시줄(Status Bar): IDE의 맨 아래에 있는 상태 표시줄은 현재 줄 및 열 번호와 같은 필수 정보를 제공하며, 줄 끝 및 코드 페이지와 같은 기능을 전환하기 위한 다양한 버튼도 포함합니다.\n\n\n\n\nVisual Studio는 풍부한 기능과 도구 세트를 제공합니다.\n\nIntegrated Development Environment (IDE), Visual Studio는 핵심적으로 종합적인 통합 개발 환경(IDE)입니다. 구문 강조, 코드 완성, 오류 검사와 같은 기능을 갖춘 강력한 코드 편집기를 제공합니다. 코드 편집기는 다양한 프로그래밍 언어를 지원하여 다양한 개발 작업에 유연하게 활용할 수 있습니다.\n솔루션 및 프로젝트 관리, Visual Studio는 코드와 리소스를 효율적으로 구성하는 데 도움이 되는 솔루션 및 프로젝트 개념을 도입합니다. 솔루션은 여러 프로젝트를 포함할 수 있으므로 복잡한 애플리케이션을 쉽게 관리할 수 있습니다. 솔루션 탐색기는 솔루션의 계층적 보기를 제공하고 프로젝트 파일을 쉽게 탐색 및 조작할 수 있게 합니다.\n디버깅 및 진단, 디버깅은 소프트웨어 개발의 중요한 부분이며 Visual Studio는 이 분야에서 탁월합니다. 중단점, 감시 창, 호출 스택과 같은 기능을 갖춘 강력한 디버거를 제공합니다. Visual Studio의 진단 도구를 사용하면 응용 프로그램 성능, 메모리 사용량 및 코드 프로파일링을 분석하여 문제를 효과적으로 식별하고 해결할 수 있습니다.\n버전 관리 통합, Visual Studio는 Git, Team Foundation Version Control (TFVC) 등과 같은 인기있는 버전 관리 시스템과 완벽하게 통합됩니다. 이 통합은 협업 개발, 효율적인 코드 공유 및 변경 사항 추적을 용이하게 합니다. IDE 내에서 직접 커밋, 분기, 병합 및 충돌 해결을 수행할 수 있습니다.\n확장성 및 마켓플레이스, Visual Studio의 확장성은 뛰어난 기능입니다. Visual Studio Marketplace에서 확장 프로그램과 애드온을 설치하여 IDE의 기능을 향상시킬 수 있습니다. 이러한 확장 프로그램은 생산성 도구에서 코드 분석 및 프로젝트 템플릿에 이르기까지 다양합니다. 마켓플레이스는 Microsoft와 커뮤니티가 만든 확장 프로그램 모두를 위한 허브입니다.\nIntelliSense, IntelliSense는 코드 완성 및 제안 기능으로 생산성을 크게 향상시킵니다. 입력할 때 상황에 맞는 제안을 제공하여 메서드 이름, 변수 이름 및 API 세부 사항을 기억해야 하는 필요성을 줄여줍니다. IntelliSense는 여러 프로그래밍 언어 및 프레임워크를 지원합니다.\n코드 리팩터링, Visual Studio에는 코드 품질과 유지 관리 보수성을 향상시키는 데 도움이 되는 코드 리팩터링 도구 세트가 포함되어 있습니다. 변수 이름 바꾸기, 메서드 추출, 필드 캡슐화 등의 작업을 몇 번의 클릭만으로 쉽게 수행할 수 있습니다. 리팩터링 도구는 깨끗하고 효율적인 코드 작성을 지원합니다.\n테스팅 및 품질 보증, Visual Studio는 단위 테스트 프레임워크, 통합 테스트 및 코드 커버리지 분석을 포함한 포괄적인 테스팅 도구를 제공합니다. 테스트 케이스를 생성하고 실행하며, 테스팅 프로세스를 자동화하고, 지속적인 통합 및 배포를 통해 소프트웨어의 품질을 보장할 수 있습니다.\n협업 및 팀 개발, Visual Studio는 Team Foundation Server (TFS) 및 Git 통합과 같은 도구를 통해 팀 구성원 간의 협업을 지원합니다. 작업 항목을 관리하고, 진행 상황을 추적하며, 팀 개발을 위한 모범 사례를 구현할 수 있습니다. 공동 코딩 기능인 Live Share를 사용하면 팀원과 실시간 코드 공유 및 디버깅이 가능합니다.",
    "crumbs": [
      "Visual Studio와 Solution"
    ]
  },
  {
    "objectID": "notes/02.html#visual-sutdio",
    "href": "notes/02.html#visual-sutdio",
    "title": "Visual Studio와 Solution",
    "section": "",
    "text": "Visual Studio는 1997년 Microsoft에서 처음 출시되었습니다. 당시에는 여러 개발 도구를 하나의 통합된 환경으로 제공하는 것을 목표로 하였습니다. 이전에는 Visual Basic, Visual C++, Visual FoxPro 등 개별적인 도구들을 사용해야 했지만, Visual Studio의 등장으로 이러한 도구들이 하나의 IDE(Integrated Development Environment, 통합 개발 환경) 안에서 통합되었습니다. 이를 통해 개발자들은 더욱 효율적으로 다양한 프로그래밍 언어를 사용하여 애플리케이션을 개발할 수 있게 되었습니다. 초기 버전의 Visual Studio는 주로 Windows 데스크톱 애플리케이션 개발에 초점을 맞추었습니다.\n2000년대에 들어서면서 웹 애플리케이션의 중요성이 커짐에 따라 Visual Studio는 ASP.NET과 같은 웹 개발 기술을 적극적으로 지원하기 시작했습니다. 또한, 엔터프라이즈급 애플리케이션 개발을 위한 기능들이 추가되면서 대규모 프로젝트 개발에도 적합한 도구로 자리매김하게 되었습니다. .NET Framework의 발전과 함께 Visual Studio는 더욱 강력한 기능을 제공하게 되었으며, 다양한 프로그래밍 언어(C#, VB.NET 등)를 지원하며 개발 생산성을 향상시키는 데 기여했습니다.\n2010년대 이후 모바일 및 클라우드 컴퓨팅이 급성장하면서 Visual Studio는 크로스 플랫폼 개발 및 클라우드 개발을 위한 지원을 강화했습니다. Xamarin을 통한 iOS, Android, Windows 등 다양한 플랫폼 대상의 모바일 앱 개발을 지원하고, Azure와의 통합을 통해 클라우드 기반 애플리케이션 개발을 용이하게 만들었습니다. 또한, 오픈 소스 생태계와의 협력을 강화하여 Git과 같은 버전 관리 시스템과의 통합을 개선하고 다양한 확장 기능을 제공하는 Visual Studio Marketplace를 통해 개발자들이 더욱 편리하게 개발할 수 있도록 지원하고 있습니다.\nVisual Studio는 출시 이후 지속적인 발전을 거듭하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 다양한 프로그래밍 언어와 플랫폼을 지원하는 통합 개발 환경으로서 개발자들이 효율적으로 고품질의 소프트웨어를 개발할 수 있도록 지원하는 핵심적인 역할을 수행하고 있습니다. 또한, 강력한 디버깅 도구, 코드 분석 기능, 테스트 도구 등을 통해 개발 과정 전반의 생산성을 향상시키는 데 기여하고 있습니다. 현재 Visual Studio는 Windows뿐만 아니라 macOS에서도 사용할 수 있는 Visual Studio for Mac, 그리고 더욱 가볍고 빠른 코드 편집기인 Visual Studio Code 등 다양한 형태로 제공되어 개발자들이 자신의 환경에 맞춰 선택하여 사용할 수 있도록 폭넓은 선택지를 제공하고 있습니다.\n\n\nVisual Studio를 처음 실행하면 사용자 설정에 맞게 다양하게 사용자 조정할 수 있는 작업 공간을 확인할 수 있습니다. 인터페이스의 주요 구성 요소는 다음과 같습니다.\n\n메뉴 바(menu bar): 상단에 위치한 메뉴 바는 파일, 편집, 보기 등과 같은 메뉴로 구성된 다양한 명령과 옵션에 대한 액세스를 제공합니다.\n도구 모음(toolbar): 메뉴 바 아래에는 자주 사용하는 도구와 작업에 대한 빠른 액세스를 제공하는 도구 모음이 있습니다. 프로젝트 빌드, 디버깅 및 실행과 같은 작업에 대한 버튼을 포함하는 경우가 많습니다.\n솔루션 탐색기(solution explorer): 화면 오른쪽에는 솔루션 탐색기가 있으며, 프로젝트 및 해당 파일을 관리하는 데 중요한 도구입니다. 솔루션과 해당 구성 요소의 계층적 보기를 표시합니다.\n코드 편집기(code editor): IDE의 중앙 영역은 코드 편집기가 차지합니다. 여기에서 소스 코드 파일을 작성, 편집 및 검토합니다. Visual Studio는 구문 강조, 코드 완성 및 오류 검사를 포함한 강력한 코드 편집 기능을 제공합니다.\n도구 창(tool windows): 이러한 창은 IDE 인터페이스에 도킹 또는 해제할 수 있는 추가 창입니다. 예를 들어 빌드 및 디버그 메시지를 표시하는 출력 창, 선택한 항목의 속성을 구성하는 속성 창, 코드 오류를 관리하는 오류 목록 창 등이 있습니다.\n솔루션 및 프로젝트 탭(solution and project tabs): 코드 편집기 위의 탭은 열려 있는 솔루션과 프로젝트를 나타냅니다. 해당 탭을 클릭하여 다른 솔루션 또는 프로젝트 간에 전환할 수 있습니다.\n상태 표시줄(Status Bar): IDE의 맨 아래에 있는 상태 표시줄은 현재 줄 및 열 번호와 같은 필수 정보를 제공하며, 줄 끝 및 코드 페이지와 같은 기능을 전환하기 위한 다양한 버튼도 포함합니다.\n\n\n\n\nVisual Studio는 풍부한 기능과 도구 세트를 제공합니다.\n\nIntegrated Development Environment (IDE), Visual Studio는 핵심적으로 종합적인 통합 개발 환경(IDE)입니다. 구문 강조, 코드 완성, 오류 검사와 같은 기능을 갖춘 강력한 코드 편집기를 제공합니다. 코드 편집기는 다양한 프로그래밍 언어를 지원하여 다양한 개발 작업에 유연하게 활용할 수 있습니다.\n솔루션 및 프로젝트 관리, Visual Studio는 코드와 리소스를 효율적으로 구성하는 데 도움이 되는 솔루션 및 프로젝트 개념을 도입합니다. 솔루션은 여러 프로젝트를 포함할 수 있으므로 복잡한 애플리케이션을 쉽게 관리할 수 있습니다. 솔루션 탐색기는 솔루션의 계층적 보기를 제공하고 프로젝트 파일을 쉽게 탐색 및 조작할 수 있게 합니다.\n디버깅 및 진단, 디버깅은 소프트웨어 개발의 중요한 부분이며 Visual Studio는 이 분야에서 탁월합니다. 중단점, 감시 창, 호출 스택과 같은 기능을 갖춘 강력한 디버거를 제공합니다. Visual Studio의 진단 도구를 사용하면 응용 프로그램 성능, 메모리 사용량 및 코드 프로파일링을 분석하여 문제를 효과적으로 식별하고 해결할 수 있습니다.\n버전 관리 통합, Visual Studio는 Git, Team Foundation Version Control (TFVC) 등과 같은 인기있는 버전 관리 시스템과 완벽하게 통합됩니다. 이 통합은 협업 개발, 효율적인 코드 공유 및 변경 사항 추적을 용이하게 합니다. IDE 내에서 직접 커밋, 분기, 병합 및 충돌 해결을 수행할 수 있습니다.\n확장성 및 마켓플레이스, Visual Studio의 확장성은 뛰어난 기능입니다. Visual Studio Marketplace에서 확장 프로그램과 애드온을 설치하여 IDE의 기능을 향상시킬 수 있습니다. 이러한 확장 프로그램은 생산성 도구에서 코드 분석 및 프로젝트 템플릿에 이르기까지 다양합니다. 마켓플레이스는 Microsoft와 커뮤니티가 만든 확장 프로그램 모두를 위한 허브입니다.\nIntelliSense, IntelliSense는 코드 완성 및 제안 기능으로 생산성을 크게 향상시킵니다. 입력할 때 상황에 맞는 제안을 제공하여 메서드 이름, 변수 이름 및 API 세부 사항을 기억해야 하는 필요성을 줄여줍니다. IntelliSense는 여러 프로그래밍 언어 및 프레임워크를 지원합니다.\n코드 리팩터링, Visual Studio에는 코드 품질과 유지 관리 보수성을 향상시키는 데 도움이 되는 코드 리팩터링 도구 세트가 포함되어 있습니다. 변수 이름 바꾸기, 메서드 추출, 필드 캡슐화 등의 작업을 몇 번의 클릭만으로 쉽게 수행할 수 있습니다. 리팩터링 도구는 깨끗하고 효율적인 코드 작성을 지원합니다.\n테스팅 및 품질 보증, Visual Studio는 단위 테스트 프레임워크, 통합 테스트 및 코드 커버리지 분석을 포함한 포괄적인 테스팅 도구를 제공합니다. 테스트 케이스를 생성하고 실행하며, 테스팅 프로세스를 자동화하고, 지속적인 통합 및 배포를 통해 소프트웨어의 품질을 보장할 수 있습니다.\n협업 및 팀 개발, Visual Studio는 Team Foundation Server (TFS) 및 Git 통합과 같은 도구를 통해 팀 구성원 간의 협업을 지원합니다. 작업 항목을 관리하고, 진행 상황을 추적하며, 팀 개발을 위한 모범 사례를 구현할 수 있습니다. 공동 코딩 기능인 Live Share를 사용하면 팀원과 실시간 코드 공유 및 디버깅이 가능합니다.",
    "crumbs": [
      "Visual Studio와 Solution"
    ]
  },
  {
    "objectID": "notes/02.html#프로젝트-유형",
    "href": "notes/02.html#프로젝트-유형",
    "title": "Visual Studio와 Solution",
    "section": "프로젝트 유형",
    "text": "프로젝트 유형\n소프트웨어 개발 분야에서 프로젝트는 코드, 리소스 및 구성을 포함하는 핵심 개체입니다. Visual Studio는 프로젝트를 효율적으로 만들고, 구성하고, 관리하기 위한 강력한 환경을 제공합니다. Visual Studio는 다양한 프로젝트 유형을 지원하며, 각 유형은 특정 개발 시나리오에 맞게 조정됩니다. 새 프로젝트를 만들 때 개발 목표에 해당하는 프로젝트 템플릿을 선택할 수 있습니다. 몇 가지 일반적인 프로젝트 유형은 다음과 같습니다.\n\n콘솔 응용 프로그램, 명령줄 인터페이스가 없는 명령 실행 응용 프로그램을 만드는 데 사용됩니다.\n클래스 라이브러리, 여러 프로젝트에서 공유할 수 있는 재사용 가능한 클래스 라이브러리를 만드는 데 사용됩니다.\n단위 테스트 프로젝트, 코드의 작은 단위 기능을 검증하도록 설계된 개별 테스트인 단위 테스트를 만드는 데 사용됩니다.\nASP.NET 웹 응용 프로그램, ASP.NET 프레임워크(Microsoft의 인기 웹 개발 프레임워크)를 사용하여 웹 응용 프로그램을 빌드하는 데 적합합니다.\n.NET MAUI APP, 하나의 C# 코드베이스로 Android, iOS, macOS, Windows에서 실행되는 네이티브 모바일 및 데스크톱 애플리케이션을 구축하기 위한 크로스 플랫폼 프레임워크를 사용하여 만든 앱입니다.",
    "crumbs": [
      "Visual Studio와 Solution"
    ]
  },
  {
    "objectID": "notes/02.html#프로젝트-생성과-솔루션",
    "href": "notes/02.html#프로젝트-생성과-솔루션",
    "title": "Visual Studio와 Solution",
    "section": "프로젝트 생성과 솔루션",
    "text": "프로젝트 생성과 솔루션\n\n파일(File) 메뉴를 클릭합니다.\n새로 만들기(New)를 선택한 다음 프로젝트(Project)를 선택합니다.\n새 프로젝트 만들기(Create a new project) 대화 상자에서 요구 사항에 따라 원하는 프로젝트 템플릿을 검색하고 선택할 수 있습니다.\n프로젝트 이름, 위치 및 솔루션 이름과 같은 프로젝트 설정을 구성합니다.\n만들기(Create) 버튼을 클릭하여 프로젝트 구조와 초기 파일을 생성합니다.\n\n\n솔루션 파일\nVisual Studio의 솔루션은 하나 이상의 프로젝트를 담을 수 있는 컨테이너입니다. 솔루션은 관련 프로젝트를 함께 그룹화하고 프로젝트 간의 종속성을 관리하는 데 사용됩니다. 새 프로젝트를 만들면 일반적으로 Visual Studio는 해당 프로젝트를 보관할 솔루션을 만듭니다. 이러한 솔루션은 탐색기를 활용해서 확인할 수 있습니다.\n솔루션 탐색기는 솔루션 내에서 프로젝트와 해당 파일을 관리하는 데 중요한 도구입니다. 보기 메뉴에서 또는 “Ctrl + Alt + L”을 눌러 액세스할 수 있습니다. 솔루션 탐색기에서는 다음을 수행할 수 있습니다:\n\n솔루션 및 프로젝트의 계층 구조를 볼 수 있습니다.\n파일을 추가, 제거 및 정리합니다.\n프로젝트 종속성을 설정합니다.\n프로젝트 속성을 구성합니다.\n\n\n\n솔루션을 구성하는 파일\n솔루션은 하나 이상의 프로젝트를 담는 컨테이너 역할을 하며, 프로젝트들은 실제 코드, 리소스, 설정 등을 포함합니다. 솔루션과 관련된 중요한 파일들을 이해하는 것은 Visual Studio를 효율적으로 사용하는 데 필수적입니다.\n\n솔루션 파일(.sln)\n\n솔루션의 구성 정보를 담고 있음\n어떤 프로젝트들이 솔루션에 포함되어 있는지, 프로젝트들의 상대적인 위치, 빌드 구성(Debug, Release 등) 정보 등을 포함\n텍스트 기반 파일이며, 직접 편집할 수도 있지만 Visual Studio에서 관리하는 것이 권장\n\n\n\n프로젝트 파일(.csproj, .vbproj, .vcxproj 등)\n\n개별 프로젝트의 구성 정보를 담고 있음\n프로젝트 유형(.NET 콘솔 앱, 웹 앱, 클래스 라이브러리 등), 포함된 파일 목록, 빌드 설정, 참조하는 라이브러리(NuGet 패키지 포함) 등을 포함\nXML 기반 파일이며, Visual Studio에서 편집하거나 직접 편집할 수 있음\n내부에 &lt;PackageReference&gt; 요소를 사용해서 NuGet 정보를 관리함\n프로젝트 유형에 따라 확장자가 달라짐\n\nC# 프로젝트: .csproj\nC++ 프로젝트: .vcxproj\nVisual Basic 프로젝트: .vbproj\n\n\n\n\n기타 중요한 파일들 (프로젝트 내):\n\n소스 코드 파일 (.cs, .vb, .cpp, .h 등): 실제 프로그램 코드를 포함하는 파일입니다.\n리소스 파일 (.resx, 이미지 파일 등): 이미지, 문자열, 아이콘 등 애플리케이션에 사용되는 리소스를 포함하는 파일입니다.\n구성 파일 (app.config, web.config, appsettings.json 등): 애플리케이션의 설정 정보를 포함하는 파일입니다.\n\n\n\n\n\n\n\n\n\n\n파일 확장자\n설명\n위치\n버전 관리\n\n\n\n\n.sln\n솔루션 구성 정보 (프로젝트 목록, 빌드 설정 등)\n솔루션 폴더\n포함\n\n\n.csproj\nC# 프로젝트 구성 정보\n프로젝트 폴더\n포함\n\n\n.vcxproj\nC++ 프로젝트 구성 정보\n프로젝트 폴더\n포함\n\n\n.cs, .cpp 등\n소스 코드 파일\n프로젝트 폴더/하위 폴더\n포함\n\n\n.resx 등\n리소스 파일\n프로젝트 폴더/하위 폴더\n포함\n\n\napp.config 등\n구성 파일 (애플리케이션 설정)\n프로젝트 폴더/하위 폴더\n포함\n\n\n\n이러한 파일들을 이해하고 관리함으로써 Visual Studio에서 프로젝트를 효과적으로 구성하고 협업 개발을 진행할 수 있습니다. 특히 .sln, .csproj 등의 파일은 버전 관리 시스템(Git 등)을 사용할 때 매우 중요하므로 주의 깊게 관리해야 합니다.\nVisual Studio에서 디버깅 시작 및 관련 기능, 오류 처리, 디버깅 도구에 대한 설명을 한국어로 번역하고 정리했습니다.",
    "crumbs": [
      "Visual Studio와 Solution"
    ]
  },
  {
    "objectID": "notes/02.html#디버깅",
    "href": "notes/02.html#디버깅",
    "title": "Visual Studio와 Solution",
    "section": "디버깅",
    "text": "디버깅\n디버깅 및 오류 처리는 개발자에게 중요한 기술이며, Visual Studio는 프로세스를 효율적이고 효과적으로 만드는 강력한 도구 세트를 제공합니다. 중단점을 설정하고, 단계별 실행 및 조사식과 같은 디버깅 기능을 사용하고, 예외를 정상적으로 처리함으로써 코드의 문제를 보다 효율적으로 식별하고 해결할 수 있습니다. 디버깅 도구 및 특수 진단 기능은 소프트웨어 프로젝트의 품질을 유지하고 개선하는 능력을 더욱 향상시킵니다.\nVisual Studio에서 애플리케이션 디버깅을 시작하는 방법은 다음과 같습니다.\n\nF5 키를 눌러 애플리케이션의 기본 시작 구성으로 디버깅을 시작합니다.\nCtrl + F5 키를 눌러 디버거를 연결하지 않고 디버깅을 시작합니다.\n\n중단점에서 멈추지 않고 애플리케이션을 실행하여 보다 자연스러운 상황에서 동작을 관찰하려는 경우에 유용합니다.\n\n디버그(Debug) 메뉴에서 디버깅 시작(Start Debugging)을 선택하거나, 도구 모음에서 디버깅 시작(Start Debugging) 버튼을 클릭합니다.\n\n\n디버깅 기능\n애플리케이션이 디버그 모드에서 실행되면 Visual Studio는 문제 분석 및 해결에 도움이 되는 여러 가지 디버깅 기능을 제공합니다.\n\n중단점 및 단계별 실행\n\n한 단계씩 코드 진행(Step Into, F11): 메서드 또는 함수 호출 내부로 들어가 해당 메서드 내의 첫 번째 코드 줄로 이동합니다.\n프로시저 단위 실행(Step Over, F10): 메서드 또는 함수 호출 내부로 들어가지 않고 실행합니다. 디버거는 현재 메서드의 다음 줄로 이동합니다.\n프로시저 나가기(Step Out, Shift + F11): 메서드 내부로 들어간 후 호출자 메서드로 돌아가려는 경우 이 작업을 사용합니다.\n커서까지 실행(Run to Cursor, Ctrl + F10): 코드 줄에 커서를 놓으면 이 명령은 해당 줄에 도달할 때까지 프로그램 실행을 계속합니다.\n\n\n\n조사식 및 로컬\n\n조사식(Watches): 코드 단계를 진행하면서 변수 또는 식의 값을 모니터링하기 위해 조사식 창에 추가할 수 있습니다.\n로컬(Locals): 로컬 창에는 현재 범위 내의 로컬 변수에 대한 정보가 표시됩니다.\n\n\n\n직접 실행 창(Immediate Window)\n직접 실행 창을 사용하면 디버깅 중에 임의의 코드를 실행하고 변수를 검사할 수 있습니다. 식을 테스트하고 코드 조각을 빠르게 평가하는 데 특히 유용합니다.\n\n\n호출 스택(Call Stack)\n호출 스택 창에는 코드의 현재 지점으로 이어진 메서드 및 함수의 호출 계층 구조가 표시됩니다. 호출 스택을 탐색하여 실행 흐름을 이해할 수 있습니다.\n\n\n디버깅 창\nVisual Studio는 출력 창, 디버그 출력 창 및 직접 실행 창과 같은 다양한 디버깅 창을 제공합니다. 이러한 창에는 디버깅에 도움이 될 수 있는 추가 정보, 로그 및 출력이 표시됩니다.\n\n\n\n디버깅 도구\n\n진단 도구, 메모리 사용량, CPU 사용량 및 애플리케이션 성능에 대한 통찰력을 제공\n성능 프로파일링, 애플리케이션 성능을 분석하고 병목 현상을 식별하기 위한 프로파일링 도구가 포함되어 있음\nIntelliTrace, 프로그램 실행 기록을 기록하여 과거에 발생한 문제를 디버깅할 수 있음\n코드 분석, 정적 코드 분석 도구를 사용하여 잠재적인 문제 및 코드 품질 개선 사항을 식별할 수 있음",
    "crumbs": [
      "Visual Studio와 Solution"
    ]
  }
]