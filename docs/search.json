[
  {
    "objectID": "notes/02.html",
    "href": "notes/02.html",
    "title": "Visual Studio와 Solution",
    "section": "",
    "text": "Visual Studio는 1997년 Microsoft에서 처음 출시되었습니다. 당시에는 여러 개발 도구를 하나의 통합된 환경으로 제공하는 것을 목표로 하였습니다. 이전에는 Visual Basic, Visual C++, Visual FoxPro 등 개별적인 도구들을 사용해야 했지만, Visual Studio의 등장으로 이러한 도구들이 하나의 IDE(Integrated Development Environment, 통합 개발 환경) 안에서 통합되었습니다. 이를 통해 개발자들은 더욱 효율적으로 다양한 프로그래밍 언어를 사용하여 애플리케이션을 개발할 수 있게 되었습니다. 초기 버전의 Visual Studio는 주로 Windows 데스크톱 애플리케이션 개발에 초점을 맞추었습니다.\n2000년대에 들어서면서 웹 애플리케이션의 중요성이 커짐에 따라 Visual Studio는 ASP.NET과 같은 웹 개발 기술을 적극적으로 지원하기 시작했습니다. 또한, 엔터프라이즈급 애플리케이션 개발을 위한 기능들이 추가되면서 대규모 프로젝트 개발에도 적합한 도구로 자리매김하게 되었습니다. .NET Framework의 발전과 함께 Visual Studio는 더욱 강력한 기능을 제공하게 되었으며, 다양한 프로그래밍 언어(C#, VB.NET 등)를 지원하며 개발 생산성을 향상시키는 데 기여했습니다.\n2010년대 이후 모바일 및 클라우드 컴퓨팅이 급성장하면서 Visual Studio는 크로스 플랫폼 개발 및 클라우드 개발을 위한 지원을 강화했습니다. Xamarin을 통한 iOS, Android, Windows 등 다양한 플랫폼 대상의 모바일 앱 개발을 지원하고, Azure와의 통합을 통해 클라우드 기반 애플리케이션 개발을 용이하게 만들었습니다. 또한, 오픈 소스 생태계와의 협력을 강화하여 Git과 같은 버전 관리 시스템과의 통합을 개선하고 다양한 확장 기능을 제공하는 Visual Studio Marketplace를 통해 개발자들이 더욱 편리하게 개발할 수 있도록 지원하고 있습니다.\nVisual Studio는 출시 이후 지속적인 발전을 거듭하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 다양한 프로그래밍 언어와 플랫폼을 지원하는 통합 개발 환경으로서 개발자들이 효율적으로 고품질의 소프트웨어를 개발할 수 있도록 지원하는 핵심적인 역할을 수행하고 있습니다. 또한, 강력한 디버깅 도구, 코드 분석 기능, 테스트 도구 등을 통해 개발 과정 전반의 생산성을 향상시키는 데 기여하고 있습니다. 현재 Visual Studio는 Windows뿐만 아니라 macOS에서도 사용할 수 있는 Visual Studio for Mac, 그리고 더욱 가볍고 빠른 코드 편집기인 Visual Studio Code 등 다양한 형태로 제공되어 개발자들이 자신의 환경에 맞춰 선택하여 사용할 수 있도록 폭넓은 선택지를 제공하고 있습니다.\n\n\nVisual Studio를 처음 실행하면 사용자 설정에 맞게 다양하게 사용자 조정할 수 있는 작업 공간을 확인할 수 있습니다. 인터페이스의 주요 구성 요소는 다음과 같습니다.\n\n메뉴 바(menu bar): 상단에 위치한 메뉴 바는 파일, 편집, 보기 등과 같은 메뉴로 구성된 다양한 명령과 옵션에 대한 액세스를 제공합니다.\n도구 모음(toolbar): 메뉴 바 아래에는 자주 사용하는 도구와 작업에 대한 빠른 액세스를 제공하는 도구 모음이 있습니다. 프로젝트 빌드, 디버깅 및 실행과 같은 작업에 대한 버튼을 포함하는 경우가 많습니다.\n솔루션 탐색기(solution explorer): 화면 오른쪽에는 솔루션 탐색기가 있으며, 프로젝트 및 해당 파일을 관리하는 데 중요한 도구입니다. 솔루션과 해당 구성 요소의 계층적 보기를 표시합니다.\n코드 편집기(code editor): IDE의 중앙 영역은 코드 편집기가 차지합니다. 여기에서 소스 코드 파일을 작성, 편집 및 검토합니다. Visual Studio는 구문 강조, 코드 완성 및 오류 검사를 포함한 강력한 코드 편집 기능을 제공합니다.\n도구 창(tool windows): 이러한 창은 IDE 인터페이스에 도킹 또는 해제할 수 있는 추가 창입니다. 예를 들어 빌드 및 디버그 메시지를 표시하는 출력 창, 선택한 항목의 속성을 구성하는 속성 창, 코드 오류를 관리하는 오류 목록 창 등이 있습니다.\n솔루션 및 프로젝트 탭(solution and project tabs): 코드 편집기 위의 탭은 열려 있는 솔루션과 프로젝트를 나타냅니다. 해당 탭을 클릭하여 다른 솔루션 또는 프로젝트 간에 전환할 수 있습니다.\n상태 표시줄(Status Bar): IDE의 맨 아래에 있는 상태 표시줄은 현재 줄 및 열 번호와 같은 필수 정보를 제공하며, 줄 끝 및 코드 페이지와 같은 기능을 전환하기 위한 다양한 버튼도 포함합니다.\n\n\n\n\nVisual Studio는 풍부한 기능과 도구 세트를 제공합니다.\n\nIntegrated Development Environment (IDE), Visual Studio는 핵심적으로 종합적인 통합 개발 환경(IDE)입니다. 구문 강조, 코드 완성, 오류 검사와 같은 기능을 갖춘 강력한 코드 편집기를 제공합니다. 코드 편집기는 다양한 프로그래밍 언어를 지원하여 다양한 개발 작업에 유연하게 활용할 수 있습니다.\n솔루션 및 프로젝트 관리, Visual Studio는 코드와 리소스를 효율적으로 구성하는 데 도움이 되는 솔루션 및 프로젝트 개념을 도입합니다. 솔루션은 여러 프로젝트를 포함할 수 있으므로 복잡한 애플리케이션을 쉽게 관리할 수 있습니다. 솔루션 탐색기는 솔루션의 계층적 보기를 제공하고 프로젝트 파일을 쉽게 탐색 및 조작할 수 있게 합니다.\n디버깅 및 진단, 디버깅은 소프트웨어 개발의 중요한 부분이며 Visual Studio는 이 분야에서 탁월합니다. 중단점, 감시 창, 호출 스택과 같은 기능을 갖춘 강력한 디버거를 제공합니다. Visual Studio의 진단 도구를 사용하면 응용 프로그램 성능, 메모리 사용량 및 코드 프로파일링을 분석하여 문제를 효과적으로 식별하고 해결할 수 있습니다.\n버전 관리 통합, Visual Studio는 Git, Team Foundation Version Control (TFVC) 등과 같은 인기있는 버전 관리 시스템과 완벽하게 통합됩니다. 이 통합은 협업 개발, 효율적인 코드 공유 및 변경 사항 추적을 용이하게 합니다. IDE 내에서 직접 커밋, 분기, 병합 및 충돌 해결을 수행할 수 있습니다.\n확장성 및 마켓플레이스, Visual Studio의 확장성은 뛰어난 기능입니다. Visual Studio Marketplace에서 확장 프로그램과 애드온을 설치하여 IDE의 기능을 향상시킬 수 있습니다. 이러한 확장 프로그램은 생산성 도구에서 코드 분석 및 프로젝트 템플릿에 이르기까지 다양합니다. 마켓플레이스는 Microsoft와 커뮤니티가 만든 확장 프로그램 모두를 위한 허브입니다.\nIntelliSense, IntelliSense는 코드 완성 및 제안 기능으로 생산성을 크게 향상시킵니다. 입력할 때 상황에 맞는 제안을 제공하여 메서드 이름, 변수 이름 및 API 세부 사항을 기억해야 하는 필요성을 줄여줍니다. IntelliSense는 여러 프로그래밍 언어 및 프레임워크를 지원합니다.\n코드 리팩터링, Visual Studio에는 코드 품질과 유지 관리 보수성을 향상시키는 데 도움이 되는 코드 리팩터링 도구 세트가 포함되어 있습니다. 변수 이름 바꾸기, 메서드 추출, 필드 캡슐화 등의 작업을 몇 번의 클릭만으로 쉽게 수행할 수 있습니다. 리팩터링 도구는 깨끗하고 효율적인 코드 작성을 지원합니다.\n테스팅 및 품질 보증, Visual Studio는 단위 테스트 프레임워크, 통합 테스트 및 코드 커버리지 분석을 포함한 포괄적인 테스팅 도구를 제공합니다. 테스트 케이스를 생성하고 실행하며, 테스팅 프로세스를 자동화하고, 지속적인 통합 및 배포를 통해 소프트웨어의 품질을 보장할 수 있습니다.\n협업 및 팀 개발, Visual Studio는 Team Foundation Server (TFS) 및 Git 통합과 같은 도구를 통해 팀 구성원 간의 협업을 지원합니다. 작업 항목을 관리하고, 진행 상황을 추적하며, 팀 개발을 위한 모범 사례를 구현할 수 있습니다. 공동 코딩 기능인 Live Share를 사용하면 팀원과 실시간 코드 공유 및 디버깅이 가능합니다."
  },
  {
    "objectID": "notes/02.html#visual-sutdio",
    "href": "notes/02.html#visual-sutdio",
    "title": "Visual Studio와 Solution",
    "section": "",
    "text": "Visual Studio는 1997년 Microsoft에서 처음 출시되었습니다. 당시에는 여러 개발 도구를 하나의 통합된 환경으로 제공하는 것을 목표로 하였습니다. 이전에는 Visual Basic, Visual C++, Visual FoxPro 등 개별적인 도구들을 사용해야 했지만, Visual Studio의 등장으로 이러한 도구들이 하나의 IDE(Integrated Development Environment, 통합 개발 환경) 안에서 통합되었습니다. 이를 통해 개발자들은 더욱 효율적으로 다양한 프로그래밍 언어를 사용하여 애플리케이션을 개발할 수 있게 되었습니다. 초기 버전의 Visual Studio는 주로 Windows 데스크톱 애플리케이션 개발에 초점을 맞추었습니다.\n2000년대에 들어서면서 웹 애플리케이션의 중요성이 커짐에 따라 Visual Studio는 ASP.NET과 같은 웹 개발 기술을 적극적으로 지원하기 시작했습니다. 또한, 엔터프라이즈급 애플리케이션 개발을 위한 기능들이 추가되면서 대규모 프로젝트 개발에도 적합한 도구로 자리매김하게 되었습니다. .NET Framework의 발전과 함께 Visual Studio는 더욱 강력한 기능을 제공하게 되었으며, 다양한 프로그래밍 언어(C#, VB.NET 등)를 지원하며 개발 생산성을 향상시키는 데 기여했습니다.\n2010년대 이후 모바일 및 클라우드 컴퓨팅이 급성장하면서 Visual Studio는 크로스 플랫폼 개발 및 클라우드 개발을 위한 지원을 강화했습니다. Xamarin을 통한 iOS, Android, Windows 등 다양한 플랫폼 대상의 모바일 앱 개발을 지원하고, Azure와의 통합을 통해 클라우드 기반 애플리케이션 개발을 용이하게 만들었습니다. 또한, 오픈 소스 생태계와의 협력을 강화하여 Git과 같은 버전 관리 시스템과의 통합을 개선하고 다양한 확장 기능을 제공하는 Visual Studio Marketplace를 통해 개발자들이 더욱 편리하게 개발할 수 있도록 지원하고 있습니다.\nVisual Studio는 출시 이후 지속적인 발전을 거듭하며 소프트웨어 개발 생태계에 큰 영향을 미쳐왔습니다. 다양한 프로그래밍 언어와 플랫폼을 지원하는 통합 개발 환경으로서 개발자들이 효율적으로 고품질의 소프트웨어를 개발할 수 있도록 지원하는 핵심적인 역할을 수행하고 있습니다. 또한, 강력한 디버깅 도구, 코드 분석 기능, 테스트 도구 등을 통해 개발 과정 전반의 생산성을 향상시키는 데 기여하고 있습니다. 현재 Visual Studio는 Windows뿐만 아니라 macOS에서도 사용할 수 있는 Visual Studio for Mac, 그리고 더욱 가볍고 빠른 코드 편집기인 Visual Studio Code 등 다양한 형태로 제공되어 개발자들이 자신의 환경에 맞춰 선택하여 사용할 수 있도록 폭넓은 선택지를 제공하고 있습니다.\n\n\nVisual Studio를 처음 실행하면 사용자 설정에 맞게 다양하게 사용자 조정할 수 있는 작업 공간을 확인할 수 있습니다. 인터페이스의 주요 구성 요소는 다음과 같습니다.\n\n메뉴 바(menu bar): 상단에 위치한 메뉴 바는 파일, 편집, 보기 등과 같은 메뉴로 구성된 다양한 명령과 옵션에 대한 액세스를 제공합니다.\n도구 모음(toolbar): 메뉴 바 아래에는 자주 사용하는 도구와 작업에 대한 빠른 액세스를 제공하는 도구 모음이 있습니다. 프로젝트 빌드, 디버깅 및 실행과 같은 작업에 대한 버튼을 포함하는 경우가 많습니다.\n솔루션 탐색기(solution explorer): 화면 오른쪽에는 솔루션 탐색기가 있으며, 프로젝트 및 해당 파일을 관리하는 데 중요한 도구입니다. 솔루션과 해당 구성 요소의 계층적 보기를 표시합니다.\n코드 편집기(code editor): IDE의 중앙 영역은 코드 편집기가 차지합니다. 여기에서 소스 코드 파일을 작성, 편집 및 검토합니다. Visual Studio는 구문 강조, 코드 완성 및 오류 검사를 포함한 강력한 코드 편집 기능을 제공합니다.\n도구 창(tool windows): 이러한 창은 IDE 인터페이스에 도킹 또는 해제할 수 있는 추가 창입니다. 예를 들어 빌드 및 디버그 메시지를 표시하는 출력 창, 선택한 항목의 속성을 구성하는 속성 창, 코드 오류를 관리하는 오류 목록 창 등이 있습니다.\n솔루션 및 프로젝트 탭(solution and project tabs): 코드 편집기 위의 탭은 열려 있는 솔루션과 프로젝트를 나타냅니다. 해당 탭을 클릭하여 다른 솔루션 또는 프로젝트 간에 전환할 수 있습니다.\n상태 표시줄(Status Bar): IDE의 맨 아래에 있는 상태 표시줄은 현재 줄 및 열 번호와 같은 필수 정보를 제공하며, 줄 끝 및 코드 페이지와 같은 기능을 전환하기 위한 다양한 버튼도 포함합니다.\n\n\n\n\nVisual Studio는 풍부한 기능과 도구 세트를 제공합니다.\n\nIntegrated Development Environment (IDE), Visual Studio는 핵심적으로 종합적인 통합 개발 환경(IDE)입니다. 구문 강조, 코드 완성, 오류 검사와 같은 기능을 갖춘 강력한 코드 편집기를 제공합니다. 코드 편집기는 다양한 프로그래밍 언어를 지원하여 다양한 개발 작업에 유연하게 활용할 수 있습니다.\n솔루션 및 프로젝트 관리, Visual Studio는 코드와 리소스를 효율적으로 구성하는 데 도움이 되는 솔루션 및 프로젝트 개념을 도입합니다. 솔루션은 여러 프로젝트를 포함할 수 있으므로 복잡한 애플리케이션을 쉽게 관리할 수 있습니다. 솔루션 탐색기는 솔루션의 계층적 보기를 제공하고 프로젝트 파일을 쉽게 탐색 및 조작할 수 있게 합니다.\n디버깅 및 진단, 디버깅은 소프트웨어 개발의 중요한 부분이며 Visual Studio는 이 분야에서 탁월합니다. 중단점, 감시 창, 호출 스택과 같은 기능을 갖춘 강력한 디버거를 제공합니다. Visual Studio의 진단 도구를 사용하면 응용 프로그램 성능, 메모리 사용량 및 코드 프로파일링을 분석하여 문제를 효과적으로 식별하고 해결할 수 있습니다.\n버전 관리 통합, Visual Studio는 Git, Team Foundation Version Control (TFVC) 등과 같은 인기있는 버전 관리 시스템과 완벽하게 통합됩니다. 이 통합은 협업 개발, 효율적인 코드 공유 및 변경 사항 추적을 용이하게 합니다. IDE 내에서 직접 커밋, 분기, 병합 및 충돌 해결을 수행할 수 있습니다.\n확장성 및 마켓플레이스, Visual Studio의 확장성은 뛰어난 기능입니다. Visual Studio Marketplace에서 확장 프로그램과 애드온을 설치하여 IDE의 기능을 향상시킬 수 있습니다. 이러한 확장 프로그램은 생산성 도구에서 코드 분석 및 프로젝트 템플릿에 이르기까지 다양합니다. 마켓플레이스는 Microsoft와 커뮤니티가 만든 확장 프로그램 모두를 위한 허브입니다.\nIntelliSense, IntelliSense는 코드 완성 및 제안 기능으로 생산성을 크게 향상시킵니다. 입력할 때 상황에 맞는 제안을 제공하여 메서드 이름, 변수 이름 및 API 세부 사항을 기억해야 하는 필요성을 줄여줍니다. IntelliSense는 여러 프로그래밍 언어 및 프레임워크를 지원합니다.\n코드 리팩터링, Visual Studio에는 코드 품질과 유지 관리 보수성을 향상시키는 데 도움이 되는 코드 리팩터링 도구 세트가 포함되어 있습니다. 변수 이름 바꾸기, 메서드 추출, 필드 캡슐화 등의 작업을 몇 번의 클릭만으로 쉽게 수행할 수 있습니다. 리팩터링 도구는 깨끗하고 효율적인 코드 작성을 지원합니다.\n테스팅 및 품질 보증, Visual Studio는 단위 테스트 프레임워크, 통합 테스트 및 코드 커버리지 분석을 포함한 포괄적인 테스팅 도구를 제공합니다. 테스트 케이스를 생성하고 실행하며, 테스팅 프로세스를 자동화하고, 지속적인 통합 및 배포를 통해 소프트웨어의 품질을 보장할 수 있습니다.\n협업 및 팀 개발, Visual Studio는 Team Foundation Server (TFS) 및 Git 통합과 같은 도구를 통해 팀 구성원 간의 협업을 지원합니다. 작업 항목을 관리하고, 진행 상황을 추적하며, 팀 개발을 위한 모범 사례를 구현할 수 있습니다. 공동 코딩 기능인 Live Share를 사용하면 팀원과 실시간 코드 공유 및 디버깅이 가능합니다."
  },
  {
    "objectID": "notes/02.html#프로젝트-유형",
    "href": "notes/02.html#프로젝트-유형",
    "title": "Visual Studio와 Solution",
    "section": "프로젝트 유형",
    "text": "프로젝트 유형\n소프트웨어 개발 분야에서 프로젝트는 코드, 리소스 및 구성을 포함하는 핵심 개체입니다. Visual Studio는 프로젝트를 효율적으로 만들고, 구성하고, 관리하기 위한 강력한 환경을 제공합니다. Visual Studio는 다양한 프로젝트 유형을 지원하며, 각 유형은 특정 개발 시나리오에 맞게 조정됩니다. 새 프로젝트를 만들 때 개발 목표에 해당하는 프로젝트 템플릿을 선택할 수 있습니다. 몇 가지 일반적인 프로젝트 유형은 다음과 같습니다.\n\n콘솔 응용 프로그램, 명령줄 인터페이스가 없는 명령 실행 응용 프로그램을 만드는 데 사용됩니다.\n클래스 라이브러리, 여러 프로젝트에서 공유할 수 있는 재사용 가능한 클래스 라이브러리를 만드는 데 사용됩니다.\n단위 테스트 프로젝트, 코드의 작은 단위 기능을 검증하도록 설계된 개별 테스트인 단위 테스트를 만드는 데 사용됩니다.\nASP.NET 웹 응용 프로그램, ASP.NET 프레임워크(Microsoft의 인기 웹 개발 프레임워크)를 사용하여 웹 응용 프로그램을 빌드하는 데 적합합니다.\n.NET MAUI APP, 하나의 C# 코드베이스로 Android, iOS, macOS, Windows에서 실행되는 네이티브 모바일 및 데스크톱 애플리케이션을 구축하기 위한 크로스 플랫폼 프레임워크를 사용하여 만든 앱입니다."
  },
  {
    "objectID": "notes/02.html#프로젝트-생성과-솔루션",
    "href": "notes/02.html#프로젝트-생성과-솔루션",
    "title": "Visual Studio와 Solution",
    "section": "프로젝트 생성과 솔루션",
    "text": "프로젝트 생성과 솔루션\n\n파일(File) 메뉴를 클릭합니다.\n새로 만들기(New)를 선택한 다음 프로젝트(Project)를 선택합니다.\n새 프로젝트 만들기(Create a new project) 대화 상자에서 요구 사항에 따라 원하는 프로젝트 템플릿을 검색하고 선택할 수 있습니다.\n프로젝트 이름, 위치 및 솔루션 이름과 같은 프로젝트 설정을 구성합니다.\n만들기(Create) 버튼을 클릭하여 프로젝트 구조와 초기 파일을 생성합니다.\n\n\n솔루션 파일\nVisual Studio의 솔루션은 하나 이상의 프로젝트를 담을 수 있는 컨테이너입니다. 솔루션은 관련 프로젝트를 함께 그룹화하고 프로젝트 간의 종속성을 관리하는 데 사용됩니다. 새 프로젝트를 만들면 일반적으로 Visual Studio는 해당 프로젝트를 보관할 솔루션을 만듭니다. 이러한 솔루션은 탐색기를 활용해서 확인할 수 있습니다.\n솔루션 탐색기는 솔루션 내에서 프로젝트와 해당 파일을 관리하는 데 중요한 도구입니다. 보기 메뉴에서 또는 “Ctrl + Alt + L”을 눌러 액세스할 수 있습니다. 솔루션 탐색기에서는 다음을 수행할 수 있습니다:\n\n솔루션 및 프로젝트의 계층 구조를 볼 수 있습니다.\n파일을 추가, 제거 및 정리합니다.\n프로젝트 종속성을 설정합니다.\n프로젝트 속성을 구성합니다.\n\n\n\n솔루션을 구성하는 파일\n솔루션은 하나 이상의 프로젝트를 담는 컨테이너 역할을 하며, 프로젝트들은 실제 코드, 리소스, 설정 등을 포함합니다. 솔루션과 관련된 중요한 파일들을 이해하는 것은 Visual Studio를 효율적으로 사용하는 데 필수적입니다.\n\n솔루션 파일(.sln)\n\n솔루션의 구성 정보를 담고 있음\n어떤 프로젝트들이 솔루션에 포함되어 있는지, 프로젝트들의 상대적인 위치, 빌드 구성(Debug, Release 등) 정보 등을 포함\n텍스트 기반 파일이며, 직접 편집할 수도 있지만 Visual Studio에서 관리하는 것이 권장\n\n\n\n프로젝트 파일(.csproj, .vbproj, .vcxproj 등)\n\n개별 프로젝트의 구성 정보를 담고 있음\n프로젝트 유형(.NET 콘솔 앱, 웹 앱, 클래스 라이브러리 등), 포함된 파일 목록, 빌드 설정, 참조하는 라이브러리(NuGet 패키지 포함) 등을 포함\nXML 기반 파일이며, Visual Studio에서 편집하거나 직접 편집할 수 있음\n내부에 &lt;PackageReference&gt; 요소를 사용해서 NuGet 정보를 관리함\n프로젝트 유형에 따라 확장자가 달라짐\n\nC# 프로젝트: .csproj\nC++ 프로젝트: .vcxproj\nVisual Basic 프로젝트: .vbproj\n\n\n\n\n기타 중요한 파일들 (프로젝트 내):\n\n소스 코드 파일 (.cs, .vb, .cpp, .h 등): 실제 프로그램 코드를 포함하는 파일입니다.\n리소스 파일 (.resx, 이미지 파일 등): 이미지, 문자열, 아이콘 등 애플리케이션에 사용되는 리소스를 포함하는 파일입니다.\n구성 파일 (app.config, web.config, appsettings.json 등): 애플리케이션의 설정 정보를 포함하는 파일입니다.\n\n\n\n\n\n\n\n\n\n\n파일 확장자\n설명\n위치\n버전 관리\n\n\n\n\n.sln\n솔루션 구성 정보 (프로젝트 목록, 빌드 설정 등)\n솔루션 폴더\n포함\n\n\n.csproj\nC# 프로젝트 구성 정보\n프로젝트 폴더\n포함\n\n\n.vcxproj\nC++ 프로젝트 구성 정보\n프로젝트 폴더\n포함\n\n\n.cs, .cpp 등\n소스 코드 파일\n프로젝트 폴더/하위 폴더\n포함\n\n\n.resx 등\n리소스 파일\n프로젝트 폴더/하위 폴더\n포함\n\n\napp.config 등\n구성 파일 (애플리케이션 설정)\n프로젝트 폴더/하위 폴더\n포함\n\n\n\n이러한 파일들을 이해하고 관리함으로써 Visual Studio에서 프로젝트를 효과적으로 구성하고 협업 개발을 진행할 수 있습니다. 특히 .sln, .csproj 등의 파일은 버전 관리 시스템(Git 등)을 사용할 때 매우 중요하므로 주의 깊게 관리해야 합니다.\nVisual Studio에서 디버깅 시작 및 관련 기능, 오류 처리, 디버깅 도구에 대한 설명을 한국어로 번역하고 정리했습니다."
  },
  {
    "objectID": "notes/02.html#디버깅",
    "href": "notes/02.html#디버깅",
    "title": "Visual Studio와 Solution",
    "section": "디버깅",
    "text": "디버깅\n디버깅 및 오류 처리는 개발자에게 중요한 기술이며, Visual Studio는 프로세스를 효율적이고 효과적으로 만드는 강력한 도구 세트를 제공합니다. 중단점을 설정하고, 단계별 실행 및 조사식과 같은 디버깅 기능을 사용하고, 예외를 정상적으로 처리함으로써 코드의 문제를 보다 효율적으로 식별하고 해결할 수 있습니다. 디버깅 도구 및 특수 진단 기능은 소프트웨어 프로젝트의 품질을 유지하고 개선하는 능력을 더욱 향상시킵니다.\nVisual Studio에서 애플리케이션 디버깅을 시작하는 방법은 다음과 같습니다.\n\nF5 키를 눌러 애플리케이션의 기본 시작 구성으로 디버깅을 시작합니다.\nCtrl + F5 키를 눌러 디버거를 연결하지 않고 디버깅을 시작합니다.\n\n중단점에서 멈추지 않고 애플리케이션을 실행하여 보다 자연스러운 상황에서 동작을 관찰하려는 경우에 유용합니다.\n\n디버그(Debug) 메뉴에서 디버깅 시작(Start Debugging)을 선택하거나, 도구 모음에서 디버깅 시작(Start Debugging) 버튼을 클릭합니다.\n\n\n디버깅 기능\n애플리케이션이 디버그 모드에서 실행되면 Visual Studio는 문제 분석 및 해결에 도움이 되는 여러 가지 디버깅 기능을 제공합니다.\n\n중단점 및 단계별 실행\n\n한 단계씩 코드 진행(Step Into, F11): 메서드 또는 함수 호출 내부로 들어가 해당 메서드 내의 첫 번째 코드 줄로 이동합니다.\n프로시저 단위 실행(Step Over, F10): 메서드 또는 함수 호출 내부로 들어가지 않고 실행합니다. 디버거는 현재 메서드의 다음 줄로 이동합니다.\n프로시저 나가기(Step Out, Shift + F11): 메서드 내부로 들어간 후 호출자 메서드로 돌아가려는 경우 이 작업을 사용합니다.\n커서까지 실행(Run to Cursor, Ctrl + F10): 코드 줄에 커서를 놓으면 이 명령은 해당 줄에 도달할 때까지 프로그램 실행을 계속합니다.\n\n\n\n조사식 및 로컬\n\n조사식(Watches): 코드 단계를 진행하면서 변수 또는 식의 값을 모니터링하기 위해 조사식 창에 추가할 수 있습니다.\n로컬(Locals): 로컬 창에는 현재 범위 내의 로컬 변수에 대한 정보가 표시됩니다.\n\n\n\n직접 실행 창(Immediate Window)\n직접 실행 창을 사용하면 디버깅 중에 임의의 코드를 실행하고 변수를 검사할 수 있습니다. 식을 테스트하고 코드 조각을 빠르게 평가하는 데 특히 유용합니다.\n\n\n호출 스택(Call Stack)\n호출 스택 창에는 코드의 현재 지점으로 이어진 메서드 및 함수의 호출 계층 구조가 표시됩니다. 호출 스택을 탐색하여 실행 흐름을 이해할 수 있습니다.\n\n\n디버깅 창\nVisual Studio는 출력 창, 디버그 출력 창 및 직접 실행 창과 같은 다양한 디버깅 창을 제공합니다. 이러한 창에는 디버깅에 도움이 될 수 있는 추가 정보, 로그 및 출력이 표시됩니다.\n\n\n\n디버깅 도구\n\n진단 도구, 메모리 사용량, CPU 사용량 및 애플리케이션 성능에 대한 통찰력을 제공\n성능 프로파일링, 애플리케이션 성능을 분석하고 병목 현상을 식별하기 위한 프로파일링 도구가 포함되어 있음\nIntelliTrace, 프로그램 실행 기록을 기록하여 과거에 발생한 문제를 디버깅할 수 있음\n코드 분석, 정적 코드 분석 도구를 사용하여 잠재적인 문제 및 코드 품질 개선 사항을 식별할 수 있음"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practice C#",
    "section": "",
    "text": "C#과 .NET\n\n\nVisual Studio와 Solution\n\n\nData, Value 그리고 Ref\n\n\n\n\n\n\n\n분기문\n\nif, else, else if\nswitch 문\nswitch 식\n\n반복문\n\nwhile\ndo while\nfor\nforeach\nbreak\ncontinue\ngoto\n\n패턴 매칭\n\n선언 패턴\n형식 패턴\n상수 패턴\n프로퍼티 패턴\n관계 패턴\n논리 패턴\n괄호 패턴\n위치 패턴\nvar 패턴\n무시 패턴\n목록 패턴\n\n메소드\n\nreturn -매개변수에 대하여\n참조에 의한 매개변수 전달\n메소드의 결과를 참조로 반환하기\n출력 전용 매개변수\n메소드 오버로딩\n가변 개수의 인수\n명명된 인수\n선택적 인수\n로컬 함수\n\n클래스\n\n생성자와 종료자\n\n생성자\n종료자\n\n정적 필드와 메소드\n객체 복사하기\nthis 키워드\n\nthis() 생성자\n\n접근 한정자로 공개 수준 결정하기\n상속으로 코드 재활용하기\n기반 클래스와 파생 클래스 사이의 형식 변환\n오버라이딩과 다형성\n메소드 숨기기\n오버라이딩 봉인하기\n읽기 전용 필드\n중첩 클래스\n분할 클래스\n확장 메소드\n구조체\n튜플\n\n\n\n\n\n\n인터페이스와 추상 클래스\n프로퍼티\n배열과 컬렉션 그리고 인덱서\n일반화 프로그래밍\n예외 처리하기\n대리자와 이벤트\n람다식\nLINQ\n리플렉션과 애트리뷰트\ndynamic 형식\n파일 다루기\n스레드와 태스크\nWinUI\n네트워크 프로그래밍\n가비지 컬렉션"
  },
  {
    "objectID": "index.html#c-학습-내용",
    "href": "index.html#c-학습-내용",
    "title": "Practice C#",
    "section": "",
    "text": "C#과 .NET\n\n\nVisual Studio와 Solution\n\n\nData, Value 그리고 Ref\n\n\n\n\n\n\n\n분기문\n\nif, else, else if\nswitch 문\nswitch 식\n\n반복문\n\nwhile\ndo while\nfor\nforeach\nbreak\ncontinue\ngoto\n\n패턴 매칭\n\n선언 패턴\n형식 패턴\n상수 패턴\n프로퍼티 패턴\n관계 패턴\n논리 패턴\n괄호 패턴\n위치 패턴\nvar 패턴\n무시 패턴\n목록 패턴\n\n메소드\n\nreturn -매개변수에 대하여\n참조에 의한 매개변수 전달\n메소드의 결과를 참조로 반환하기\n출력 전용 매개변수\n메소드 오버로딩\n가변 개수의 인수\n명명된 인수\n선택적 인수\n로컬 함수\n\n클래스\n\n생성자와 종료자\n\n생성자\n종료자\n\n정적 필드와 메소드\n객체 복사하기\nthis 키워드\n\nthis() 생성자\n\n접근 한정자로 공개 수준 결정하기\n상속으로 코드 재활용하기\n기반 클래스와 파생 클래스 사이의 형식 변환\n오버라이딩과 다형성\n메소드 숨기기\n오버라이딩 봉인하기\n읽기 전용 필드\n중첩 클래스\n분할 클래스\n확장 메소드\n구조체\n튜플\n\n\n\n\n\n\n인터페이스와 추상 클래스\n프로퍼티\n배열과 컬렉션 그리고 인덱서\n일반화 프로그래밍\n예외 처리하기\n대리자와 이벤트\n람다식\nLINQ\n리플렉션과 애트리뷰트\ndynamic 형식\n파일 다루기\n스레드와 태스크\nWinUI\n네트워크 프로그래밍\n가비지 컬렉션"
  },
  {
    "objectID": "notes/01.html",
    "href": "notes/01.html",
    "title": "C#과 .NET",
    "section": "",
    "text": "C#은 Microsoft에서 1999년에 개발한 프로그래밍 언어입니다. 현대적이고 객체 지향적인 언어로, .NET 프레임워크에서 실행되도록 설계되었습니다. C#의 문법은 C++ 및 Java와 유사합니다. C#은 출시된 이후 여러 번의 개정을 거쳐 새로운 기능을 추가했습니다. 오늘날 C#은 Windows 데스크톱 애플리케이션, 웹 애플리케이션, 게임 및 모바일 앱 개발에 활용할 수 있습니다.\n\n\n\n파일 범위 네임스페이스(File-scoped namespace), 기존에는 네임스페이스를 감싸는 중괄호 {} 를 사용해야 했습니다. C# 10에서는 파일 최상단에 한 줄로 선언이 가능합니다. 코드 중첩이 줄어들어 가독성과 유지보수성이 향상됩니다.\n\n// after\nnamespace MyApp\n{\n    class Program\n    {\n        static void Main() { }\n    }\n}\n\n// before\nnamespace MyApp;\n\nclass Program\n{\n    static void Main() { }\n}\n\n전역 using 지시문(Global using directives), using 지시문을 전역으로 선언하여, 모든 파일에서 공통으로 사용할 수 있도록 해줍니다. 프로젝트 전역에서 공통 사용되는 네임스페이스를 한 곳에 모아 정리할 수 있어, 코드 중복을 줄입니다.\n\n// GlobalUsings.cs (프로젝트 내 한 곳에만 작성)\nglobal using System;\nglobal using System.Collections.Generic;\n\n// 다른 파일 어디서든 System, System.Collections.Generic를 별도의 using 없이 사용 가능\nnamespace MyApp;\n\npublic class Demo\n{\n    public List&lt;string&gt; Names { get; set; } = new();\n}\n\nRecord structs, C# 9에서 소개된 record는 기본적으로 참조 타입이었으나, C# 10부터는 값 타입인 구조체 형태도 지원합니다. 구조체의 값 복사 특성과 레코드의 불변성 및 편의 기능을 동시에 활용할 수 있습니다.\n\npublic record struct Point(int X, int Y);\nvar p1 = new Point(3, 4);\nvar p2 = p1 with { Y = 10 }; \n// 구조체지만 record로 선언했기 때문에 with 식 사용 가능\nConsole.WriteLine(p2); // Point { X = 3, Y = 10 }\n\n람다 식 개선(Lambda improvements), 람다 식에서 반환 형식을 컴파일러가 추론할 수 있으며, 람다 식에 속성(Attribute)을 붙일 수 있습니다. 매개변수가 없는 람다 식에서 _(디스카드)를 사용해도 됩니다.\n\nFunc&lt;int, int&gt; square = [MyAttribute] x =&gt; x * x; \n// 반환형 추론, Attribute 적용 가능\nvar print = () =&gt; Console.WriteLine(\"Hello\");\nprint();\n\n상수 문자열 보간(Constant interpolated strings), 상수(const) 필드에서도 문자열 보간이 가능해졌습니다.\n\nconst string Greeting = \"Hello\";\nconst string Message = $\"{Greeting}, World!\"; \n// C# 9까지는 불가, C# 10에서는 가능\n\n\n\n\n원시 문자열 리터럴(Raw string literals), 문자열을 \"\"\"로 둘러싸, 특수문자나 줄바꿈을 이스케이프 없이 그대로 표현할 수 있습니다. JSON, XML, Markdown 등의 멀티라인 문자열을 가독성 좋게 표현할 수 있습니다.\n\nstring raw = \"\"\"\n    이것은 \"원시\" 문자열입니다.\n    \\n, \\t 등을 이스케이프 처리하지 않아도 됩니다.\n\"\"\";\nConsole.WriteLine(raw);\n\nUTF-8 문자열 리터럴(UTF-8 string literals), 문자열 리터럴 뒤에 u8 접미사를 붙여 UTF-8 인코딩된 바이트 배열을 직접 생성할 수 있습니다. 별도의 인코딩 과정 없이 UTF-8 바이트 배열을 얻을 수 있어 성능상 이점이 있습니다.\n\nReadOnlySpan&lt;byte&gt; utf8Bytes = \"안녕하세요\"u8;\nConsole.WriteLine(utf8Bytes.Length);  // UTF-8로 인코딩된 길이\n\nrequired, 객체나 레코드가 생성될 때 반드시 초기화해야 하는 필드를 지정할 수 있습니다. 중요한 필드의 누락을 컴파일 시간에 미리 방지할 수 있습니다.\n\npublic class Person\n{\n    public required string Name { get; init; }\n    public int Age { get; init; }\n}\nvar p = new Person { Name = \"Alice\", Age = 30 }; \n// Name은 반드시 설정, Age는 선택\n\n정적 추상 멤버(Static abstract members in interfaces), 인터페이스에 정적 추상 멤버를 정의할 수 있어, 제네릭 수학 연산 등 다양한 패턴을 지원합니다. +, - 연산자나 수학 관련 함수를 제네릭에서 간단히 이용할 수 있어, 수치 라이브러리 구현이 용이해집니다.\n\npublic interface IAddition&lt;TSelf&gt; where TSelf : IAddition&lt;TSelf&gt;\n{\n    static abstract TSelf operator +(TSelf left, TSelf right);\n}\n\npublic struct MyInt : IAddition&lt;MyInt&gt;\n{\n    public int Value { get; set; }\n    public MyInt(int value) =&gt; Value = value;\n\n    public static MyInt operator +(MyInt left, MyInt right)\n        =&gt; new MyInt(left.Value + right.Value);\n}\n\n리스트 패턴(List patterns), 배열이나 리스트를 패턴 매칭으로 검사할 수 있습니다. 배열의 특정 형태를 깔끔하게 검사할 수 있습니다.\n\nint[] numbers = { 1, 2, 3 };\n// 완벽 일치\nif (numbers is [1, 2, 3]) Console.WriteLine(\"numbers는 1,2,3으로 구성\");\nif (numbers is [1, ..]) Console.WriteLine(\"첫 번째 요소가 1\");\n\nfile 접근 한정자(File-scoped types), file 한정자를 사용해 해당 파일 내에서만 유효한 클래스(또는 구조체, 열거형 등)를 선언할 수 있습니다. 특정 파일에서만 사용하는 헬퍼 타입 등을 은닉하여, 네임스페이스 오염을 줄일 수 있습니다.\n\nfile class MyFileScopedClass\n{\n    // 이 파일 바깥에서는 접근 불가\n}\n\n\n\n\n클래스/구조체용 기본 생성자 (Primary constructors for non-record types), 레코드가 아닌 일반 클래스나 구조체에서도 생성자 매개변수를 클래스 선언부에 직접 선언할 수 있습니다. 레코드에서 사용하던 간결한 생성자 문법을 일반 클래스/구조체에도 적용 가능해집니다.\n\nclass Person(string name, int age) \n{\n    public string Name { get; } = name;\n    public int Age { get; } = age;\n}\nvar p = new Person(\"Alice\", 30);\nConsole.WriteLine(p.Name); // \"Alice\"\n\nusing 별칭 지시문(Using alias directive) 확장, 임의의 타입이나 멤버에 대해 using 별칭을 지정할 수 있도록 확장될 예정입니다. 긴 네임스페이스나 자주 쓰는 멤버를 짧게 별칭화하여 가독성을 높입니다.\n\nusing MyInt = System.Int32;\nusing static System.Math;\nConsole.WriteLine(Sqrt(25)); // using static System.Math 덕분에 바로 Sqrt 사용\n\n람다 파라미터 기본값(Default values for lambda parameters), 람다 식의 매개변수에 기본값을 지정할 수 있게 됩니다. 메서드와 동일한 방식으로 매개변수의 기본값을 설정할 수 있어, 코드가 더 간결해집니다.\n\nFunc&lt;int, int, int&gt; add = (x = 0, y = 0) =&gt; x + y;\nConsole.WriteLine(add());      // 0\nConsole.WriteLine(add(5));     // 5\nConsole.WriteLine(add(5, 10)); // 15",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#c",
    "href": "notes/01.html#c",
    "title": "C#과 .NET",
    "section": "",
    "text": "C#은 Microsoft에서 1999년에 개발한 프로그래밍 언어입니다. 현대적이고 객체 지향적인 언어로, .NET 프레임워크에서 실행되도록 설계되었습니다. C#의 문법은 C++ 및 Java와 유사합니다. C#은 출시된 이후 여러 번의 개정을 거쳐 새로운 기능을 추가했습니다. 오늘날 C#은 Windows 데스크톱 애플리케이션, 웹 애플리케이션, 게임 및 모바일 앱 개발에 활용할 수 있습니다.\n\n\n\n파일 범위 네임스페이스(File-scoped namespace), 기존에는 네임스페이스를 감싸는 중괄호 {} 를 사용해야 했습니다. C# 10에서는 파일 최상단에 한 줄로 선언이 가능합니다. 코드 중첩이 줄어들어 가독성과 유지보수성이 향상됩니다.\n\n// after\nnamespace MyApp\n{\n    class Program\n    {\n        static void Main() { }\n    }\n}\n\n// before\nnamespace MyApp;\n\nclass Program\n{\n    static void Main() { }\n}\n\n전역 using 지시문(Global using directives), using 지시문을 전역으로 선언하여, 모든 파일에서 공통으로 사용할 수 있도록 해줍니다. 프로젝트 전역에서 공통 사용되는 네임스페이스를 한 곳에 모아 정리할 수 있어, 코드 중복을 줄입니다.\n\n// GlobalUsings.cs (프로젝트 내 한 곳에만 작성)\nglobal using System;\nglobal using System.Collections.Generic;\n\n// 다른 파일 어디서든 System, System.Collections.Generic를 별도의 using 없이 사용 가능\nnamespace MyApp;\n\npublic class Demo\n{\n    public List&lt;string&gt; Names { get; set; } = new();\n}\n\nRecord structs, C# 9에서 소개된 record는 기본적으로 참조 타입이었으나, C# 10부터는 값 타입인 구조체 형태도 지원합니다. 구조체의 값 복사 특성과 레코드의 불변성 및 편의 기능을 동시에 활용할 수 있습니다.\n\npublic record struct Point(int X, int Y);\nvar p1 = new Point(3, 4);\nvar p2 = p1 with { Y = 10 }; \n// 구조체지만 record로 선언했기 때문에 with 식 사용 가능\nConsole.WriteLine(p2); // Point { X = 3, Y = 10 }\n\n람다 식 개선(Lambda improvements), 람다 식에서 반환 형식을 컴파일러가 추론할 수 있으며, 람다 식에 속성(Attribute)을 붙일 수 있습니다. 매개변수가 없는 람다 식에서 _(디스카드)를 사용해도 됩니다.\n\nFunc&lt;int, int&gt; square = [MyAttribute] x =&gt; x * x; \n// 반환형 추론, Attribute 적용 가능\nvar print = () =&gt; Console.WriteLine(\"Hello\");\nprint();\n\n상수 문자열 보간(Constant interpolated strings), 상수(const) 필드에서도 문자열 보간이 가능해졌습니다.\n\nconst string Greeting = \"Hello\";\nconst string Message = $\"{Greeting}, World!\"; \n// C# 9까지는 불가, C# 10에서는 가능\n\n\n\n\n원시 문자열 리터럴(Raw string literals), 문자열을 \"\"\"로 둘러싸, 특수문자나 줄바꿈을 이스케이프 없이 그대로 표현할 수 있습니다. JSON, XML, Markdown 등의 멀티라인 문자열을 가독성 좋게 표현할 수 있습니다.\n\nstring raw = \"\"\"\n    이것은 \"원시\" 문자열입니다.\n    \\n, \\t 등을 이스케이프 처리하지 않아도 됩니다.\n\"\"\";\nConsole.WriteLine(raw);\n\nUTF-8 문자열 리터럴(UTF-8 string literals), 문자열 리터럴 뒤에 u8 접미사를 붙여 UTF-8 인코딩된 바이트 배열을 직접 생성할 수 있습니다. 별도의 인코딩 과정 없이 UTF-8 바이트 배열을 얻을 수 있어 성능상 이점이 있습니다.\n\nReadOnlySpan&lt;byte&gt; utf8Bytes = \"안녕하세요\"u8;\nConsole.WriteLine(utf8Bytes.Length);  // UTF-8로 인코딩된 길이\n\nrequired, 객체나 레코드가 생성될 때 반드시 초기화해야 하는 필드를 지정할 수 있습니다. 중요한 필드의 누락을 컴파일 시간에 미리 방지할 수 있습니다.\n\npublic class Person\n{\n    public required string Name { get; init; }\n    public int Age { get; init; }\n}\nvar p = new Person { Name = \"Alice\", Age = 30 }; \n// Name은 반드시 설정, Age는 선택\n\n정적 추상 멤버(Static abstract members in interfaces), 인터페이스에 정적 추상 멤버를 정의할 수 있어, 제네릭 수학 연산 등 다양한 패턴을 지원합니다. +, - 연산자나 수학 관련 함수를 제네릭에서 간단히 이용할 수 있어, 수치 라이브러리 구현이 용이해집니다.\n\npublic interface IAddition&lt;TSelf&gt; where TSelf : IAddition&lt;TSelf&gt;\n{\n    static abstract TSelf operator +(TSelf left, TSelf right);\n}\n\npublic struct MyInt : IAddition&lt;MyInt&gt;\n{\n    public int Value { get; set; }\n    public MyInt(int value) =&gt; Value = value;\n\n    public static MyInt operator +(MyInt left, MyInt right)\n        =&gt; new MyInt(left.Value + right.Value);\n}\n\n리스트 패턴(List patterns), 배열이나 리스트를 패턴 매칭으로 검사할 수 있습니다. 배열의 특정 형태를 깔끔하게 검사할 수 있습니다.\n\nint[] numbers = { 1, 2, 3 };\n// 완벽 일치\nif (numbers is [1, 2, 3]) Console.WriteLine(\"numbers는 1,2,3으로 구성\");\nif (numbers is [1, ..]) Console.WriteLine(\"첫 번째 요소가 1\");\n\nfile 접근 한정자(File-scoped types), file 한정자를 사용해 해당 파일 내에서만 유효한 클래스(또는 구조체, 열거형 등)를 선언할 수 있습니다. 특정 파일에서만 사용하는 헬퍼 타입 등을 은닉하여, 네임스페이스 오염을 줄일 수 있습니다.\n\nfile class MyFileScopedClass\n{\n    // 이 파일 바깥에서는 접근 불가\n}\n\n\n\n\n클래스/구조체용 기본 생성자 (Primary constructors for non-record types), 레코드가 아닌 일반 클래스나 구조체에서도 생성자 매개변수를 클래스 선언부에 직접 선언할 수 있습니다. 레코드에서 사용하던 간결한 생성자 문법을 일반 클래스/구조체에도 적용 가능해집니다.\n\nclass Person(string name, int age) \n{\n    public string Name { get; } = name;\n    public int Age { get; } = age;\n}\nvar p = new Person(\"Alice\", 30);\nConsole.WriteLine(p.Name); // \"Alice\"\n\nusing 별칭 지시문(Using alias directive) 확장, 임의의 타입이나 멤버에 대해 using 별칭을 지정할 수 있도록 확장될 예정입니다. 긴 네임스페이스나 자주 쓰는 멤버를 짧게 별칭화하여 가독성을 높입니다.\n\nusing MyInt = System.Int32;\nusing static System.Math;\nConsole.WriteLine(Sqrt(25)); // using static System.Math 덕분에 바로 Sqrt 사용\n\n람다 파라미터 기본값(Default values for lambda parameters), 람다 식의 매개변수에 기본값을 지정할 수 있게 됩니다. 메서드와 동일한 방식으로 매개변수의 기본값을 설정할 수 있어, 코드가 더 간결해집니다.\n\nFunc&lt;int, int, int&gt; add = (x = 0, y = 0) =&gt; x + y;\nConsole.WriteLine(add());      // 0\nConsole.WriteLine(add(5));     // 5\nConsole.WriteLine(add(5, 10)); // 15",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#net",
    "href": "notes/01.html#net",
    "title": "C#과 .NET",
    "section": ".NET",
    "text": ".NET\n.NET은 Microsoft에서 개발한 소프트웨어 개발 플랫폼입니다. 2002년 처음 출시된 이후 윈도우 애플리케이션 개발을 위한 강력한 도구로 자리매김했으며, 현재는 웹, 모바일, 게임, IoT, AI 등 다양한 분야에서 활용되고 있습니다. .NET은 개발자가 다양한 프로그래밍 언어를 사용하여 애플리케이션을 구축할 수 있도록 지원하며, 풍부한 라이브러리와 도구를 제공하여 개발 생산성을 향상시킵니다. 은 아래와 같습니다.\n\n.NET의 주요 특징\n\n다양한 언어 지원, C#, F#, Visual Basic 등 다양한 프로그래밍 언어를 지원\n크로스 플랫폼, .NET Core 이후 버전부터는 윈도우, macOS, Linux 등 다양한 운영체제에서 실행 가능\n풍부한 라이브러리: 다양한 작업을 위한 풍부한 클래스 라이브러리를 제공\n뛰어난 성능: Just-In-Time (JIT) 컴파일을 통해 높은 성능을 제공\n\n\n\n.NET의 장점\n\n생산성 향상, 풍부한 라이브러리와 도구를 통해 개발 시간을 단축하고 생산성을 향상시킬 수 있음\n유지 보수 용이성, 객체 지향 프로그래밍 및 모듈식 설계를 통해 코드를 쉽게 유지 보수할 수 있음\n안정성, 강력한 형식 검사 및 예외 처리 메커니즘을 통해 안정적인 애플리케이션을 개발할 수 있음\n확장성, .NET 애플리케이션은 높은 확장성을 제공하여 대규모 시스템 구축에 적합\n\n\n\n.NET의 변화: 과거와 현재\n.NET은 처음 출시된 이후 지속적인 발전을 거듭해왔습니다. 초기에는 윈도우 데스크톱 애플리케이션 개발에 중점을 두었지만, 현재는 웹, 모바일, 클라우드, 게임 등 다양한 분야에서 활용될 수 있도록 진화했습니다. 이러한 변화는 .NET Framework에서 .NET Core로의 전환, 그리고 .NET 5, 6, 7, 8, 9로 이어지는 통합 및 발전 과정을 통해 이루어졌습니다.\n\n.NET Framework 시대 (2002년 ~ 2016년)\n.NET Framework는 2002년 처음 출시되었습니다. 윈도우 운영체제에서 애플리케이션을 개발하고 실행하기 위한 프레임워크로, C#, Visual Basic, F# 등 다양한 언어를 지원했습니다. .NET Framework는 윈도우 데스크톱 애플리케이션, 웹 애플리케이션, 웹 서비스 등 다양한 애플리케이션 개발에 널리 사용되었습니다. 당시에는 윈도우 운영체제에 종속적이었습니다. ASP.NET 웹 프레임워크를 통해 웹 애플리케이션 개발을 지원하였고, Windows Forms 및 WPF를 통해 데스크톱 애플리케이션 개발을 지원하였습니다. .NET Framework는 윈도우 애플리케이션 개발에 큰 영향을 미쳤지만, 윈도우 운영체제에 종속적이라는 한계를 가지고 있었습니다. 이러한 한계를 극복하고 크로스 플랫폼 지원을 위해 .NET Core가 등장하게 됩니다.\n\n\n.NET Core 시대 (2016년 ~ 2020년)\n.NET Framework의 한계를 극복하고 크로스 플랫폼 지원, 오픈 소스 생태계 확장, 성능 향상을 목표로 2016년 .NET Core가 출시되었습니다. .NET Core는 모듈식 디자인을 채택하여 개발자가 필요한 구성 요소만 선택적으로 사용할 수 있도록 하였고, 이는 애플리케이션의 크기를 줄이고 배포를 용이하게 했습니다. 또한, 명령줄 인터페이스(CLI)를 통해 개발자가 다양한 플랫폼에서 애플리케이션을 빌드하고 실행할 수 있도록 지원했습니다. 윈도우, macOS, Linux 등 다양한 운영체제에서 실행 가능하도록 개선하였고, .NET Core는 오픈 소스 프로젝트로, 개발자 커뮤니티의 참여를 통해 빠르게 발전했습니다. 필요한 구성 요소만 선택적으로 사용할 수 있어 애플리케이션 크기를 줄이고 배포를 용이하게 합니다. .NET Framework 대비 성능이 크게 향상되었습니다. CLI를 통해 다양한 플랫폼에서 애플리케이션을 빌드하고 실행할 수 있습니다. .NET Core는 크로스 플랫폼 지원 및 오픈 소스 생태계 확장을 통해 .NET 플랫폼의 새로운 가능성을 열었습니다. 이후 .NET 5를 통해 .NET Framework와 .NET Core는 하나의 통합된 플랫폼으로 발전하게 됩니다.\n\n\n통합과 발전 (2020년 ~ 현재)\n2020년 11월, Microsoft는 .NET 5를 출시하며 .NET Framework와 .NET Core를 하나의 통합된 플랫폼으로 발전시켰습니다. .NET 5는 단일 코드 베이스로 윈도우, macOS, Linux, iOS, Android 등 다양한 플랫폼에서 실행 가능한 애플리케이션을 개발할 수 있도록 지원합니다. 또한, 성능 향상, 새로운 언어 기능 추가, 클라우드 네이티브 지원 강화 등 다양한 개선 사항을 포함했습니다. .NET 5 이후, Microsoft는 매년 새로운 버전의 .NET을 출시하며 플랫폼을 지속적으로 발전시키고 있습니다. .NET 6는 .NET MAUI를 통해 크로스 플랫폼 모바일 및 데스크톱 애플리케이션 개발을 지원하고, C# 10의 새로운 기능을 도입했습니다. .NET 7은 성능 향상과 클라우드 네이티브 지원 강화에 중점을 두었으며, .NET 8은 Blazor United를 통해 웹 UI 개발을 개선하고, .NET MAUI를 통해 윈도우 데스크톱 애플리케이션 개발을 지원합니다. .NET 9는 C# 12의 새로운 기능을 도입하고, 플랫폼 전반의 성능과 안정성을 향상시켰습니다.  \n\n\n\n\n\n\n\n\n\n\n버전\n출시일\n지원 유형 (대략)\n주요 특징\n지원 상태\n\n\n\n\n.NET 8\n2023년 11월 예정 (계획)\nLTS\n- Native AOT 개선  - 컨테이너 지원 확대  - 지속적인 성능 및 언어 기능 개선\n미출시 (프리뷰 진행 중)\n\n\n.NET 7\n2022년 11월 8일\n단기 지원(STS, 약 18개월)\n- Native AOT 기본 지원  - 컨테이너 성능 최적화  - C# 11 등 최신 언어 기능  - 전반적 성능 개선\n지원 중\n\n\n.NET 6\n2021년 11월 8일\n장기 지원(LTS, 3년)\n- C# 10, F# 6 지원  - Minimal APIs  - .NET MAUI  - 핫 리로드, 성능 개선 등\n지원 중\n\n\n.NET 5\n2020년 11월 10일\n단기 지원(STS, 약 18개월)\n- 단일 파일 배포  - 성능 및 컨테이너 개선  - .NET Core와 .NET Framework의 통합 시도\n지원 종료 (2022년 5월 10일)\n\n\n.NET Core 3.1\n2019년 12월 3일\n장기 지원(LTS, 3년)\n- Windows 데스크톱 (WinForms, WPF) 공식 지원  - 전반적 성능 및 기능 개선\n지원 종료 (2022년 12월 13일)\n\n\n.NET Core 3.0\n2019년 9월 23일\n단기 지원(STS, 약 18개월)\n- C# 8 지원  - Blazor 서버  - Worker Service 템플릿  - 성능 개선\n지원 종료 (2020년 3월 3일)\n\n\n.NET Core 2.2\n2018년 12월 4일\n단기 지원(STS, 약 18개월)\n- ASP.NET Core 강화  - 추가 성능 최적화\n지원 종료 (2019년 12월 23일)\n\n\n.NET Core 2.1\n2018년 5월 30일\n장기 지원(LTS, 3년)\n- Razor 클래스 라이브러리  - SignalR, gRPC 등  - Entity Framework Core 개선\n지원 종료 (2021년 8월 21일)\n\n\n.NET Core 2.0\n2017년 8월 14일\n단기 지원(STS, 약 18개월)\n- 성능 개선 및 self-contained 배포  - 새로운 csproj 구조\n지원 종료 (2018년 10월 1일)\n\n\n.NET Core 1.1\n2016년 11월 16일\n단기 지원(STS, 약 18개월)\n- 신규 API 추가  - 툴링 및 안정성 개선\n지원 종료 (2019년 6월 27일)\n\n\n.NET Core 1.0\n2016년 6월 27일\n장기 지원(LTS, 3년)\n- 초기 크로스 플랫폼 지원  - CLI 기반 개발 환경 도입\n지원 종료 (2019년 6월 27일)\n\n\n\n\n\n\nCLR\nCLR(Common Language Runtime)은 .NET에서 프로그램이 실행될 때 동작을 관리해 주는 엔진(또는 환경)입니다. 마치 자동차 엔진이 자동차의 작동을 책임지듯, .NET 프로그램이 안전하고 일관된 방식으로 실행될 수 있도록 다양한 기능을 제공합니다. C# 같은 고수준 언어는 사람에게 읽기 쉽지만, 컴퓨터가 직접 이해하기엔 적합하지 않습니다. 그래서 중간 단계인 IL(Intermediate Language) 코드를 거친 뒤, CLR이 이를 실제 기계어(컴퓨터가 바로 실행할 수 있는 언어)로 바꿔주어야 프로그램이 동작합니다. 이렇게 하면 여러 운영 체제나 하드웨어에서도 공통된 방식으로 실행될 수 있습니다.\n안전성과 편의성: 메모리 관리, 예외 처리와 같은 자잘하지만 중요한 부분들을 자동으로 처리해 줍니다. 덕분에 프로그래머는 주로 프로그램의 로직에만 집중할 수 있습니다.\n\n\nCLR의 주요 기능\n\n가비지 수집(Garbage Collection), 가비지 수집(Garbage Collection, GC) 은 프로그램이 사용했던 메모리 중 더 이상 사용하지 않는 부분을 CLR이 알아서 정리해 주는 기능입니다.수동으로 메모리를 관리하려면 ’어디서 할당하고 어디서 해제해야 할까?’를 계속 생각해야 하는데, GC 덕분에 그 부담을 줄일 수 있습니다. 메모리를 잘못 정리하면 프로그램이 오작동하거나 멈출 수 있는데, GC가 자동으로 해 주므로 안전성이 높아집니다.\nJIT 컴파일(Just-In-Time Compilation), C# 코드 → IL 코드 → (실행 시점에) → 기계어 코드이 순서로 변환되는데, IL 코드를 최종적으로 기계어로 바꿔 주는 역할을 CLR이 맡습니다. 이 과정을 JIT(Just-In-Time) 컴파일 이라고 합니다. “Just-In-Time”이라는 이름대로, 미리 전부 변환해 두는 것이 아니라 실행에 필요한 순간에 해당 코드를 컴파일합니다. 이렇게 하면 시작 시점의 부담을 줄이고, 실행되는 부분만 빠르게 기계어로 변환할 수 있어 효율적입니다.\n어셈블리(Assembly) 로딩 및 관리, .NET에서 코드를 묶어 배포하는 단위를 어셈블리(Assembly) 라고 부릅니다. (보통 .dll 또는 .exe 확장자를 가집니다.) CLR은 필요한 어셈블리를 찾아서 프로그램이 잘 쓸 수 있도록 관리하고, 실행 도중에 보안이나 버전 충돌을 점검하기도 합니다.\n타입 시스템 관리, .NET에는 다양한 자료형(int, string, double 등)이 있는데, 이들을 한데 묶어 통합적으로 정의한 것을 Common Type System(CTS) 라고 합니다. CLR은 CTS를 기반으로 모든 언어(C#, VB.NET 등)에서 동일한 자료형을 다룰 수 있게 해 줍니다. 예를 들어, C#에서 int 타입은 VB.NET의 Integer 타입과 사실상 동일한 구조를 갖습니다. CLR이 내부적으로 같은 구조를 공유하도록 관리하기 때문이죠.\n예외 처리 및 디버깅 지원, 프로그램이 실행될 때 오류(예외)가 발생하면, CLR이 예외를 인식하고 이를 프로그램에게 알려줄 수 있도록 구조를 갖추고 있습니다. 또한 CLR은 디버깅(문제 해결을 위해 프로그램 내부를 조사하는 과정)과 프로파일링(프로그램의 성능을 측정하고 분석하는 기능)을 지원해 줍니다.\n\n\nCLR의 이점\n\n안전한 메모리 관리, GC 덕분에 메모리 누수를 일으키기 쉬운 실수를 줄일 수 있습니다.\n높은 호환성, IL 코드를 기반으로 JIT 컴파일되므로, 여러 플랫폼에서 동일한 프로그램을 실행할 수 있습니다(플랫폼 전용 .NET 런타임을 사용).\n개발 생산성, 예외 처리, 디버깅, 형식 안전성, 풍부한 라이브러리 지원 덕분에 개발 속도가 빨라지고 오류도 줄일 수 있습니다.\n다양한 언어 지원, CLR 덕분에 C#, VB.NET, F#, Python(.NET용 IronPython) 등 다양한 언어가 서로 어셈블리를 공유하면서 .NET 위에서 돌아갈 수 있습니다.",
    "crumbs": [
      "C#과 .NET"
    ]
  },
  {
    "objectID": "notes/01.html#c과.net의-관계",
    "href": "notes/01.html#c과.net의-관계",
    "title": "C#과 .NET",
    "section": "C#과.NET의 관계",
    "text": "C#과.NET의 관계\nC#은 프로그래밍 언어이고, .NET은 애플리케이션을 개발하고 실행하기 위한 플랫폼입니다. C#은 .NET 플랫폼에서 실행되는 여러 언어 중 하나이며, .NET은 C# 코드를 실행하는 데 필요한 환경을 제공합니다. C# 언어 자체는 변수, 데이터 유형, 연산자, 제어문, 함수 등 프로그래밍의 기본적인 구성 요소를 제공합니다 . 또한 객체 지향 프로그래밍, 제네릭, LINQ 등과 같은 고급 기능도 제공합니다. 반면 .NET은 CLR(Common Language Runtime), 기본 클래스 라이브러리(BCL), 그리고 다양한 API와 프레임워크를 제공합니다 . CLR은 C# 코드를 실행하는 런타임 환경이며, BCL은 문자열 처리, 파일 입출력, 네트워킹 등과 같은 일반적인 작업을 위한 클래스 라이브러리를 제공합니다. .NET은 또한 ASP.NET, Windows Forms, WPF, Xamarin 등과 같은 다양한 애플리케이션 프레임워크를 제공합니다. C#은 .NET 플랫폼에서 애플리케이션을 개발하기 위한 도구이며, .NET은 C# 코드를 실행하고 다양한 기능을 제공하는 환경입니다. 둘은 서로 협력하여 강력하고 다양한 애플리케이션을 개발할 수 있도록 지원합니다.",
    "crumbs": [
      "C#과 .NET"
    ]
  }
]